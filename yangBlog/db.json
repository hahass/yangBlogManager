{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/ayer/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/ayer/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/clipboard.styl","path":"css/clipboard.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.css","path":"dist/main.css","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.js","path":"dist/main.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/report.html","path":"dist/report.html","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/404.jpg","path":"images/404.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.png","path":"images/ayer.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/beian.png","path":"images/beian.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/forkme.png","path":"images/forkme.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/mouse.cur","path":"images/mouse.cur","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom1.js","path":"js/clickBoom1.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickBoom2.js","path":"js/clickBoom2.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/sponsor.jpg","path":"images/sponsor.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/wechat.jpg","path":"images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/dz.js","path":"js/dz.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/categories/index.md","hash":"0ae5a83f4d9f8e55c9b8f1f84138b83ea90815fa","modified":1604420425635},{"_id":"source/_posts/jvm/java-jvm-1.md","hash":"46ad674b2d6be7c6e9026df9913e6453df4fa94e","modified":1606962422907},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1.md","hash":"107a84b3f312e6781febffcc033efa9b34ff7f1b","modified":1604420006589},{"_id":"source/tags/index.md","hash":"a727fda9b80e340f2052e807a56501f47888e77c","modified":1604422675081},{"_id":"source/_posts/jvm/java-jvm-命令的使用.md","hash":"ac6ef0360093135665bbccb05a41b7ea410ec46e","modified":1606973739546},{"_id":"source/_posts/jvm/java-jvm-手动实现yangGC.md","hash":"6bfa187656e43fd4121cfcf949fab53c83034537","modified":1606360903234},{"_id":"source/_posts/springboot/springboot-frist.md","hash":"26def37a05ca39359db556fe896fdb5f2ce15b59","modified":1604420055848},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm.md","hash":"3547169e72a813ba119dc820b33cd7db8ee775ef","modified":1604420006759},{"_id":"source/_posts/blog/firstBlog.md","hash":"9bcc452ca3dd76707718f732a6da13d1e87ee642","modified":1606360903234},{"_id":"source/_posts/jvm/java-jvm-object.md","hash":"d5d48c85fe8477493c8f4181a142a228b971e9aa","modified":1604420006993},{"_id":"source/_posts/springboot/springboot-yml.md","hash":"46dd9b3c8d4d4048e35eb46e63ceebd8dc2ad13e","modified":1604420055882},{"_id":"source/_posts/日常/jar包冲突.md","hash":"34609d8059ccfd85920a19bf47b6faf0327b3cf0","modified":1605172245520},{"_id":"source/_posts/jvm/java-jvm-gc-memory.md","hash":"669e164a60a7843ae5921268219d586815358713","modified":1604420006847},{"_id":"source/_posts/日常/Vscode使用技巧.md","hash":"a824beb6138deb89269cc5e56c704ff99468fb1b","modified":1606360903235},{"_id":"source/_posts/日常/markdown使用技巧.md","hash":"adcd9bd70194527e53d31f1a73c9f133df29429e","modified":1606360903235},{"_id":"source/_posts/日常/得到-20-11-4.md","hash":"b2aa1fcbdb98fa25774f3236f4e9105638923b25","modified":1606360903236},{"_id":"source/_posts/日常/得到-20-11.md","hash":"e777b528186492a0593c17b1c9600a2260555b7e","modified":1606360903236},{"_id":"source/_posts/设计模式/设计模式原则.md","hash":"549a40ee30ba6c220c80fc2f618bfa4f403f8858","modified":1605526692717},{"_id":"source/_posts/tomcat/tomcat-1-http协议.md","hash":"9a6d2fe9ad5c397f86dd94483d48d1153237388a","modified":1606975778133},{"_id":"source/_posts/jvm/java-jvm-gc.md","hash":"9ec0c463e4cc77cb2fa2cf21507ea4f39513fa77","modified":1604420006894},{"_id":"source/_posts/jvm/java-jvm-1/jvm_area.png","hash":"853a035a185109220b4cd15392580b98d7ae7853","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc/GCRoots.png","hash":"2f4a819ca6824654ecc4bf7516a498ac559525ea","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1/cms.png","hash":"bd2cb03ab6671cbd5c504dd95651151e7e11a25a","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1/GClog.png","hash":"553998554999f3d9f9b72ad14ebe6f40d965d5d3","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1/parnew.png","hash":"1e3c080c50e77c312f9dea06988b4b69d343a126","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1/serial.png","hash":"7783b411902f4135c1dfc79d4d7dd85bd076b5d1","modified":1604406544483},{"_id":"source/_posts/日常/lambda-自定义函数接口.md","hash":"a64b52839ba590e01763c628617c06500d94eab5","modified":1606973738395},{"_id":"source/_posts/jvm/java-jvm-monitor/jps.png","hash":"e252e07a99595b46259ecab18cc7798a2d9a4b40","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/fuzhi2.png","hash":"983c391bc2d3cdb7fd7687c5f77c20180e9ca9aa","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/biaojizhengli.png","hash":"3813f2a4d5971b3020fef5c266cceff005c26f45","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/biaojizhengli1.png","hash":"eeadd612bf8e550f237e52525eaf36661707aae6","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/fuzhi1.png","hash":"c4ff83e28a8f3ca3c4be423bce1688f249e7e095","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-命令的使用/jps1.png","hash":"0a9cde0cb83a85342ac5cc63a25eb70b8bff4764","modified":1606361353599},{"_id":"source/_posts/jvm/java-jvm-命令的使用/jps2.png","hash":"c96ca7f3b71daa0dc34cd6589e18d70524921aea","modified":1606361451450},{"_id":"source/_posts/jvm/java-jvm-命令的使用/jps3.png","hash":"a5c81367bc7b8ebef8c348a5f4d354588d114a36","modified":1606361588934},{"_id":"source/_posts/jvm/java-jvm-命令的使用/stat1.png","hash":"03e57ddf1c017eab21feb4dd595c78c40ba6bcc6","modified":1606368673807},{"_id":"source/_posts/springboot/springboot-frist/springboot1.png","hash":"95f8e708d08e076de2c5926dff0424c6fe7ae918","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-monitor.md","hash":"83226fc81b3635b9fd98d0eb3d84f12bef3cf954","modified":1604420006944},{"_id":"source/_posts/springboot/springboot-frist/springboot4.png","hash":"f13d0d41538e2c46172b16047b3b2d971e220eea","modified":1604406544483},{"_id":"source/_posts/blog/firstBlog/11.png","hash":"31b80a2397b51201b2e01d5ab28c1febdaaa72c2","modified":1604406544483},{"_id":"source/_posts/blog/firstBlog/newfirstBlog.png","hash":"cc13dfbf1243b062125ad43d9df92435045c6a48","modified":1604406544483},{"_id":"source/_posts/springboot/springboot-frist/springboot2.png","hash":"b322b73072996ec9f46500e48eb846fd74bcbea0","modified":1604406544483},{"_id":"source/_posts/日常/jar包冲突/maven插件.png","hash":"df4fc4571b60d579483d97d245692a57791e6f5b","modified":1605172245526},{"_id":"source/_posts/blog/firstBlog/nodejs.png","hash":"47e62b5bd29e0d1b3c3c25502667c5b26bdee2bb","modified":1604419019569},{"_id":"themes/ayer/.gitignore","hash":"b98cc63ded46b5c538f5ff5c911ec435e7917e7c","modified":1604406544483},{"_id":"source/_posts/日常/jar包冲突/启动失败.jpg","hash":"567d262e534ead764223b401f9b5d97d21c5cde5","modified":1605172245531},{"_id":"source/_posts/日常/jar包冲突/界面.png","hash":"8db328e410db7e44b3b4767d26b9ca5e11b4d31a","modified":1605172245542},{"_id":"source/_posts/springboot/springboot-frist/springboot3.png","hash":"cb95540c74c34f55278b8b6fa8ce22005d7a6a4d","modified":1604406544483},{"_id":"source/_posts/设计模式/建造者模式/简单工厂模式.md","hash":"00c1dbf70bb7170ea9b4a4ee8eb6364fb1396790","modified":1605526962186},{"_id":"themes/ayer/.npmignore","hash":"ed209b94b968aece8313d9d8408337f3545c4bc0","modified":1604406544483},{"_id":"themes/ayer/.postcssrc","hash":"1dd8ddbf9ba6fd3748d0b93c1f0f3d95ec918bf0","modified":1604406544483},{"_id":"themes/ayer/.stylintrc","hash":"557d72b4dcd86e66fc5c688595288cf06b12ce6c","modified":1604406544483},{"_id":"themes/ayer/_config.yml","hash":"e958a7edea1ec6c9c1683b76778bc072374fed03","modified":1604464672505},{"_id":"themes/ayer/package.json","hash":"0955266cff5b9164c1d185fccde432c7eac5634e","modified":1604414627608},{"_id":"themes/ayer/.travis.yml","hash":"e351a8d7687d44b56f5387b7b6b054c51f0e83e5","modified":1604406544483},{"_id":"themes/ayer/logo.png","hash":"16fbb131601570b21890a922cd6e596691ccff42","modified":1604406544483},{"_id":"themes/ayer/index.js","hash":"19292aa9df268dbab8ac51a2a3aa7a20ac1eb00a","modified":1604406544483},{"_id":"themes/ayer/LICENSE","hash":"e39066a824465f4d6ad5ce7903b4d683d38d2b6c","modified":1604406544483},{"_id":"themes/ayer/languages/de.yml","hash":"1e7546c0dad156e6b02d441e3aab10131320f4db","modified":1604406544483},{"_id":"themes/ayer/move_config.js","hash":"e310bdb9a8738e506e53a40bd3cd895008d4cd61","modified":1604406544483},{"_id":"themes/ayer/languages/default.yml","hash":"a0fb73d1d8d9c229efb4b3871219d74ed86ad8e0","modified":1604406544483},{"_id":"themes/ayer/languages/en.yml","hash":"a0fb73d1d8d9c229efb4b3871219d74ed86ad8e0","modified":1604406544483},{"_id":"themes/ayer/languages/es.yml","hash":"987a4849119ad68b020bacc9e683fc028281b635","modified":1604406544483},{"_id":"themes/ayer/languages/fr.yml","hash":"74ef0cfb3459bfebbeeb979c2023e704042ba0ad","modified":1604406544483},{"_id":"themes/ayer/languages/ja.yml","hash":"32f13fbc6747d89241359258a832023da6b588b1","modified":1604406544483},{"_id":"themes/ayer/languages/ko.yml","hash":"3a3a896337d4406ae3ea9a2a947b29419f34f29c","modified":1604406544483},{"_id":"themes/ayer/languages/no.yml","hash":"5d6c4e1b69f46be84981db0b6017f21a0adb5d6c","modified":1604406544483},{"_id":"themes/ayer/languages/pt.yml","hash":"4f35faa308a5b29d71bc4106f5d2ce429e2cc769","modified":1604406544483},{"_id":"themes/ayer/languages/nl.yml","hash":"5b2704dd940769726d151a70d6d88f6b505a2a63","modified":1604406544483},{"_id":"themes/ayer/languages/zh-TW.yml","hash":"4ab9ddb40bdb45818079ae571bc8edf937ba5e39","modified":1604406544483},{"_id":"themes/ayer/layout/categories.ejs","hash":"c40f84aacdf7d33cfcb4eb9f78f331dad699abff","modified":1604406544483},{"_id":"themes/ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1604406544483},{"_id":"themes/ayer/languages/ru.yml","hash":"7dac0d5a9137ce772ba368e72bdaf3a3d5d355d1","modified":1604406544483},{"_id":"themes/ayer/languages/zh-CN.yml","hash":"9793d7532f9331d6729125a0970f1991d6bc18ec","modified":1604406544483},{"_id":"themes/ayer/layout/page.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1604406544483},{"_id":"themes/ayer/layout/friends.ejs","hash":"18382cd4429588e58bf046beacaed06704832fe3","modified":1604406544483},{"_id":"themes/ayer/languages/vi.yml","hash":"cdf3b1d9e84566dafcce7654a3d0ec1dcdc6be97","modified":1604406544483},{"_id":"themes/ayer/layout/plain-page.ejs","hash":"39cce1936f5f0e2feb924a7af2f52a631d81b84f","modified":1604406544483},{"_id":"themes/ayer/layout/tags.ejs","hash":"88b34dd8d7b1e64fa27aa6ed72af996cf6700809","modified":1604406544483},{"_id":"themes/ayer/layout/index.ejs","hash":"77347cbb8635611d8b1fb84bde75f9dedaf8632d","modified":1604406544483},{"_id":"themes/ayer/layout/post.ejs","hash":"a9a48ae63f5d68a36382951166fdd6e482b901f1","modified":1604406544483},{"_id":"themes/ayer/scripts/default_config.js","hash":"70d6ee032d75410d540b6789b5949739a47f0125","modified":1604406544483},{"_id":"themes/ayer/layout/layout.ejs","hash":"070f82309fae1c1eb6afa2e331c7005654760db6","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/after-footer.ejs","hash":"4bdb0221990417e559a2045a1733ef3a518f7c5e","modified":1604406544483},{"_id":"themes/ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1604406544483},{"_id":"themes/ayer/source-src/main.js","hash":"77e753cd66579316c8c9e07e673c31ddb6e8e7f2","modified":1604406544484},{"_id":"themes/ayer/layout/_partial/archive-post.ejs","hash":"9be7173badcca6582c1136204adb3aa432aada21","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/ayer.ejs","hash":"c152f7eefe949914019f875e16bc8046e4b5b253","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/archive.ejs","hash":"cb8d23ea2efb55a8412ae08417638a9abb5a13b9","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/article.ejs","hash":"b6e9567054b3b262fd212a18a75d1d5dcb6161a3","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/broadcast.ejs","hash":"c228fa93bcf2f8403729342854211ea976df9a9f","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/google-analytics.ejs","hash":"5b389110f4d3b727c33c48f088a8bc7f8b577d19","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/footer.ejs","hash":"1407c1043fdb628642de9d2990921d92a3c2f078","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/katex.ejs","hash":"ff2822fd2f6e8a02ce781aecf5bb031db076e882","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/modal.ejs","hash":"cf441365eff1f8143e3c9ae54954d0ebe0a358e5","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/head.ejs","hash":"26dceb25434ee7bf8f6ce01b58daafe2a482ab53","modified":1604406544483},{"_id":"themes/ayer/scripts/filters/index.js","hash":"e435b782178da75656f9616c7af564fb9ff0de50","modified":1604406544483},{"_id":"themes/ayer/source/404.html","hash":"6f7743b6fceb16708c89cde40d66a3fa18f24a1d","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/mathjax.ejs","hash":"4d633c6cc375a0c81fe0ed2a114b1ac4c3cec2d9","modified":1604406544483},{"_id":"themes/ayer/scripts/helpers/ayer-plus-vendors.js","hash":"7b3df58faaa875d17afbf74ddef5601116f2ce3d","modified":1604406544483},{"_id":"themes/ayer/scripts/filters/meta_generator.js","hash":"58f4c93d22e4eb9743915223444335fb6fe06d21","modified":1604406544483},{"_id":"themes/ayer/scripts/helpers/wordcount.js","hash":"f9c8fceb2130929b8f11e22b1c3476c99d1574a8","modified":1604406544483},{"_id":"themes/ayer/scripts/lib/core.js","hash":"7908a82a86d63f35c6f785cacb1cfaf99ae7e0f9","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/music.ejs","hash":"cde5caf73f120b1300ec7539bbf675597688c734","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/sidebar.ejs","hash":"e3b411aef6e5f25f6c5c66b93d653ef70da8d4af","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/viewer.ejs","hash":"6663c30882e2b375b15c147080c70d0dcce54a6f","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/totop.ejs","hash":"43ba0cd1f9e898bcbd873b1e9a2d47249d6aaf77","modified":1604406544483},{"_id":"themes/ayer/source/css/clipboard.styl","hash":"017f9b628806eeb199da2e77485cd9ac8e2117b3","modified":1604406544483},{"_id":"themes/ayer/source/css/custom.styl","hash":"636de689fecfdda6cb4c6ce169fae2c89204f20a","modified":1604406544483},{"_id":"themes/ayer/source/dist/main.css","hash":"62d662504967cd5896c3f918ea0e974fdac18dc7","modified":1604406544483},{"_id":"themes/ayer/source/images/404.jpg","hash":"4f36a8d378712427cded03f5166949f5e0ba754c","modified":1604406544483},{"_id":"themes/ayer/source/dist/main.js","hash":"68b1b6cd15f6038d757fa280281073128162b5ce","modified":1604406544483},{"_id":"themes/ayer/source/images/ayer-side.svg","hash":"ad004ce7a873de0f91774f3d5923e010396a07bd","modified":1604406544483},{"_id":"themes/ayer/source/images/ayer.svg","hash":"379c3307f97c364718a1dbc1e52fb14de12eb11a","modified":1604406544483},{"_id":"themes/ayer/source/images/ayer.png","hash":"0466c05244273f645d239cd27513bfa3c50308aa","modified":1604406544483},{"_id":"themes/ayer/source/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1604406544483},{"_id":"themes/ayer/source/images/cover7.jpg","hash":"573bff6899d2d9c5bcba0dc9c60cd1ec9eb8b029","modified":1604406544484},{"_id":"themes/ayer/source/images/forkme.png","hash":"99c3e21a169421e4f249befb428396c729863a75","modified":1604406544484},{"_id":"themes/ayer/source/images/mouse.cur","hash":"c1ffe93a6ba0d25ef06bb3d097560762e4807593","modified":1604406544484},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1604406544484},{"_id":"themes/ayer/source/images/sponsor.jpg","hash":"b3efa167f50cad85404c83f21dec2be570ed21dc","modified":1604406544484},{"_id":"themes/ayer/source/js/clickBoom2.js","hash":"bea5232eb8b32542283d9a28257f4b85ce2f3c1b","modified":1604406544484},{"_id":"themes/ayer/source/js/search.js","hash":"dad2e216ad550ff4e9d8363d40b50bd7dbd4e3fe","modified":1606360903237},{"_id":"themes/ayer/source/js/clickBoom1.js","hash":"56582907b4c2ece5187b8d64125f91ddabb8a24e","modified":1604406544484},{"_id":"themes/ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_darkmode.styl","hash":"219753a5cf40cfbd557fbde01a71f589e6de4327","modified":1604406544484},{"_id":"themes/ayer/source/js/dz.js","hash":"079ae73e2e396c2e00919a50a6fe0d064f99303a","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_extend.styl","hash":"8dedef428b6ac7d629e1d1f6039b0f60dacc4c5e","modified":1604406544484},{"_id":"themes/ayer/source-src/css/style.styl","hash":"ed0b9028f1f54206f1bc912b12ed4bef47c88a0a","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_mixins.styl","hash":"6959409df2dd0a1ca05be0c0e9b2a884efdfb82d","modified":1604406544484},{"_id":"themes/ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1604406544484},{"_id":"themes/ayer/source/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_remixicon.styl","hash":"138284a4842820a7f2bf38c26d3d5c5b0e2219e9","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_variables.styl","hash":"910dd0682971a616e1610daec23e7ff5a556df98","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_normalize.styl","hash":"630e719b9e805a26182a37152435d4787c0f1734","modified":1604406544484},{"_id":"themes/ayer/source-src/js/share.js","hash":"a65e4645818e4eb8d4a40d0499e1d04b6ee224bd","modified":1604406544484},{"_id":"themes/ayer/layout/_partial/post/busuanzi.ejs","hash":"4a6b6300284876a2008f2b13067d2c77cd41e26e","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/category.ejs","hash":"85f0ebeceee1c32623bfa1e4170dbe1e34442fea","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1604406544483},{"_id":"themes/ayer/source-src/js/ayer.js","hash":"acc2b740765f8fc3b0e8c27f3226cc74b865f127","modified":1605172193228},{"_id":"themes/ayer/layout/_partial/post/albums.ejs","hash":"cfb16c9dda7a609776a28702e0c3854a52e422a7","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/gitalk.ejs","hash":"917ef5daea9c926aea4703ab3e9911c9f6d16b64","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/gallery.ejs","hash":"5f8487fe7bed9a09001c6655244ff35f583cf1eb","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/clipboard.ejs","hash":"d6f82b35bbb060ec22c5facf0eea67cf44c396f6","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/justifiedGallery.ejs","hash":"4a21fd3d7335ffcd0661036fee81a927c125e2e2","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/minivaline.ejs","hash":"35de54173ebae3135fc548ba8e52390fdbe585c0","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/nav.ejs","hash":"e59198918e92ef92156aeefbf6023584ac1cae64","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/title.ejs","hash":"3b076a65b9847cd6e0d424f5c2874046ef51d4d9","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/search.ejs","hash":"2c9d19d1685e834aa2020998da2a2d259ce9b9ff","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/tocbot.ejs","hash":"9898b0dd9237e21908ba40292a8a9f947bed44d2","modified":1604406544483},{"_id":"themes/ayer/source-src/css/_partial/albums.styl","hash":"0659d5f7469f24a415354ff767d949926465d515","modified":1604406544484},{"_id":"themes/ayer/layout/_partial/post/topping.ejs","hash":"fea793e132f627a8148059a9aee8bc33550506d1","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/share.ejs","hash":"0a364766931f48df60b7c92fec8fde1067a93e00","modified":1604406544483},{"_id":"themes/ayer/source-src/css/_partial/archive.styl","hash":"3044bf059522e79a726265c9a2f603ec8dc4222d","modified":1604406544484},{"_id":"themes/ayer/layout/_partial/post/valine.ejs","hash":"bcabccb083df3d2c669c6471167de46ba3ca19c8","modified":1604406544483},{"_id":"themes/ayer/layout/_partial/post/word.ejs","hash":"4b8e8455709debd73fba6bf3aad63378c4156dc1","modified":1604406544483},{"_id":"themes/ayer/source-src/css/_partial/apple.styl","hash":"e06dce604cc58ec39d677e4e59910c2725684901","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/ayer.styl","hash":"da46e69f7ecc779ec137deb601c3524524fd758d","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/categories.styl","hash":"3b11d0c6c4439b0856ba81c50bd8867d5bb081da","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/articles.styl","hash":"39a0bc6c5cf85f0527d6ee81f6feebce8550c1dd","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/article.styl","hash":"a8b0982dc252a2b801a6443d90a04937d4ccc1a3","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/footer.styl","hash":"1a4576c38ef19834a4d0a8ac887e7b55d21f2f13","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/float.styl","hash":"d888df89a172e4c8119cb8740fc1eae1a9539157","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/gallery.styl","hash":"7bdc2c9fb4971dbd7511c5cbb69bd611f20db591","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/friends.styl","hash":"9dd116846c92daee1c8f80b79cab231613b164b2","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/gitalk.styl","hash":"3706eef2e0541493f1679a30241d279e29dfdc17","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/highlight.styl","hash":"e894b3a1aff76e84137e1e6db59a75afd0a53f52","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/justifiedGallery.styl","hash":"f2f43ae9831c3df017b35c68caa94f5eb911f697","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/lists.styl","hash":"da8a82a48852411c10e279dfee43038d46f4f273","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/navbar.styl","hash":"bc477e4905ab88da711e0049ac3866dd1f88f80a","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/pace.styl","hash":"bde7bf3577c66a3ac829410d52fa2144212282ef","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/mobile.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/layout.styl","hash":"b1bcdd213115c2fa8331d4e0f620dc7bcad64dc5","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/tocbot.styl","hash":"c5db921f8e11a7c2a340c8f1e1d93d50ade2ae1f","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/search.styl","hash":"f81076fc6d4a83be3371bcb79ab54d88e2605714","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/tag.styl","hash":"87df748185edfba222c3f9a4b9ef8eee0e8e5ad3","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/reward.styl","hash":"a8a069ea34a0fd043832890db5341405e9f462cd","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/share.styl","hash":"9ce2dd3ffdc4e170dfcb975a7158f913bc40b8d8","modified":1604406544484},{"_id":"themes/ayer/source-src/css/_partial/totop.styl","hash":"9e9d8dc167ed2c332e4520cbf41244c34c1ebf64","modified":1604406544484},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/biaojiqingchu2.png","hash":"c9b979e2f6d00ac8cfc20846c75516173de9fda9","modified":1604406544483},{"_id":"themes/ayer/source-src/css/_partial/sidebar.styl","hash":"600c70f1de82da5223af290d47a583f9c379d188","modified":1604406544484},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/biaojiqingchu1.png","hash":"bf234534bb4b92207cb6d6868da10208b93be745","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-object/zhijiezhizhen.png","hash":"1d5f6692643c009120e12331056fdfb78af447ec","modified":1604406544483},{"_id":"source/_posts/jvm/java-jvm-object/jubinchi.png","hash":"822d01e642a883c2e436c8506ef08e017f9800e4","modified":1604406544483},{"_id":"source/_posts/tomcat/tomcat-1-http协议/http原理.png","hash":"3e7339349e34c820254a1917c0f2d966b3e34718","modified":1606974504414},{"_id":"themes/ayer/source/images/alipay.jpg","hash":"8f5409e29764fca573f1d274003910aa3c919de1","modified":1604406544483},{"_id":"themes/ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1604406544483},{"_id":"themes/ayer/source/images/wechat.jpg","hash":"93a362574a8498e75dca469b7bceb0b321fda387","modified":1604406544484},{"_id":"themes/ayer/source/js/jquery-2.0.3.min.js","hash":"800edb7787c30f4982bf38f2cb8f4f6fb61340e9","modified":1604406544484},{"_id":"themes/ayer/source/dist/report.html","hash":"ceda29d9248324eb24a22e59227a850f84f7493e","modified":1604406544483},{"_id":"themes/ayer/source/images/cover6.jpg","hash":"a5b8a5dddff2607fee5fccf5fdef3b214a8468cc","modified":1604406544484},{"_id":"themes/ayer/screenshots/hexo-theme-ayer.png","hash":"4111670e622ce09837b6b9cc641782af75805079","modified":1604406544483},{"_id":"themes/ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1604406544483},{"_id":"themes/ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1604406544483},{"_id":"themes/ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1604406544483},{"_id":"themes/ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1604406544484}],"Category":[{"name":"JAVA_JVM","_id":"cki8f5xzz000454vi2bmd9v78"},{"name":"SpringBoot","_id":"cki8f5y0b000o54vi0p4y2oc5"},{"name":"记录","_id":"cki8f5y0l001554vi0ufgavhf"},{"name":"tomcat","_id":"cki8f5y0n001c54vi9xk64s8p"},{"name":"日常","_id":"cki8f5y0q001j54vi6sru7iqh"},{"name":"日常比较","_id":"cki8f5y0x001q54vidb4fccmk"},{"name":"得到","_id":"cki8f5y0z001x54vibyt77vm7"},{"name":"设计模式","_id":"cki8f5y12002954vi57cj6iq8"},{"name":"技巧","parent":"cki8f5y0q001j54vi6sru7iqh","_id":"cki8f5y13002c54vi57g5eht9"}],"Data":[],"Page":[{"title":"categories","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\nlayout: \"categories\"\n---","date":"2020-11-04T04:16:08.674Z","updated":"2020-11-03T16:20:25.635Z","path":"categories/index.html","comments":1,"_id":"cki8f5xzr000054via5010k1c","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\nlayout: \"tags\"\n---","date":"2020-11-04T04:16:08.676Z","updated":"2020-11-03T16:57:55.081Z","path":"tags/index.html","comments":1,"_id":"cki8f5xzy000254vi2xff1b7z","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JVM学习笔记-运行时数据区域","date":"2019-05-21T07:35:37.000Z","_content":"\n\n&#160; &#160; &#160; &#160;​java虚拟机在运行java程序的时候，会将内存划分成不同的数据区域，每个区域负责不同的功能，通常分为：方法区、虚拟机栈、本地方法栈。接下来我们一一介绍这些概念。\n\n![jvm_area.png](./jvm_area.png)\n\n\n### 1.程序计数器\n\n&#160; &#160; &#160; &#160;​程序计数器是一块非常小的内存，它是当前线程所执行的字节码的行号指示器。在虚拟机的概念里，字节码解释器是通过改变这个计数器的值来选取下一个需要执行的字节码指令， 分支、循环、异常处理、线程恢复都依赖这个程序计数器来完成。\n&#160; &#160; &#160; &#160;java多线程执行是通过不停切换处理器来分别执行各个线程实现的，也就是同一时刻只有一个处理器只能执行一条线程，每个线程执行一段时间在执行其他的线程，所以每个线程都需要有自己独立的程序计数器，才能在处理器切回自己线程的时候，继续正确执行，所以**程序计时器是线程私有的**。\n&#160; &#160; &#160; &#160;程序计数器是java虚拟机唯一一个没有OutOfMemoryError的区域。\n\n### 2.java虚拟机栈\n\n&#160; &#160; &#160; &#160;java虚拟机栈描述的是java方法执行的内存模型，每个方法执行的时候，会在创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等。同时栈是线程私有的，生命周期与线程相同。\n&#160; &#160; &#160; &#160;局部变量表存放了编译器可知的各种基本数据类型（boolean，byte，char,short,int,float,long,double）、对象引用和returnAddress类型。\n&#160; &#160; &#160; &#160;64位长度的long和double类型的数据会占用两个局部变量的空间，其余的数据类型都只占用1个空间。局部变量表需要的空间，在编译期间完成分配，当进入一个方法时，这个方法需要的在栈分配的大小是完全确定的在方法运行时，局部变量表的大小不会改变。\n&#160; &#160; &#160; &#160;这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverFlowError异常。如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。\n\n\n\n### 3.本地方法栈\n\n&#160; &#160; &#160; &#160;本地方法栈与java虚拟机栈非常相似，虚拟机栈为java方法服务，而本地方法栈为Native方法服务。\n\n### 4.java堆\n\n&#160; &#160; &#160; &#160;堆是java虚拟机管理的最大的一块内存。在虚拟机启动的时候创建，并且是线程共享的。java堆主要用于存放对象实例。几乎所有的对象实例都在这里分配内存。\n&#160; &#160; &#160; &#160;​java堆也是垃圾收集器主要处理的区域。很多时候也被叫做“GC堆”，从内存回收的角度来看，现在收集器基本都采用分代收集法，所有java堆可以细分为新生代和老年代，在细分一点就是Eden空间、From Survivor空间、To Survivor空间。\n&#160; &#160; &#160; &#160;根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。\n\n&#160; &#160; &#160; &#160;如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。\n\n\n### 5.方法区\n\n&#160; &#160; &#160; &#160;方法区是线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。java虚拟机规范吧方法区描述为堆的一个逻辑部分，但是他也有一个别名Non-Heap(非堆)。目的与java堆分区开。\n&#160; &#160; &#160; &#160;习惯HotSpot虚拟机的开发者，更愿意把方法区成为“永久代”，本质上两种不等价，仅仅因为HotSpot虚拟机的设计团队选择吧GC分代收集扩展到方法区。或者说永久代来实现方法区而已。这样HotSpot的垃圾收集器可以向管理java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。\n&#160; &#160; &#160; &#160;java虚拟机堆方法区的限制非常宽松，不需要联系的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域比较少出现，但是并非数据进入了方法区就不收集了。这个区域内存回收的主要目标是针对常量池的回收和对类型的卸载。一般这个区域回收条件比较苛刻，但是回收还是有必要的。\n&#160; &#160; &#160; &#160;当方法区无法申请到足够的内存的时候，也会抛出OutOfMemoryError异常。\n\n### 6.运行时常量池\n\n&#160; &#160; &#160; &#160; 方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。在常量池无法在申请到内存会抛出OutOfMemoryError。\n&#160; &#160; &#160; &#160;运行时常量池有一个重要的特征-具备动态性。java语言不要求常量一定只有在编译器才能产生，运行期间也可以能将新的常量放在池中，这种特性被开发人员利用比较多的便是String类的intern()方法。\n\n\n### 7.加课：OutOfMemoryError异常\n\n- <font color='red'>堆</font>\n\njava堆用于存储对象实例，只要不断创建对象，并且保证 GC Roots 到对象之间有可达路径，对象数量达到最大堆的容量限制就会产生内存溢出异常。\n\n堆抛出 java.lang.OutOfMemoryError会进一步提示 java heap space.\n\n要解决堆异常，一般需要通过内存映像分析工具对Dump处理的堆转储快照进行分析，重点是确定内存中对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。\n\n如果内存泄漏，通过工具查看泄漏对象到GC Roots的引用链。就能找到泄漏对象是通过怎样的路劲与GC Roots相关联并导致垃圾收集器无法自动回收他们的，掌握了泄漏对象的类型信息以及GC Roots引用链的信息，就能比较准确定位泄漏代码的位置。\n\n如果不存在泄漏。检查虚拟机的堆参数与机器物料内存对比，是否还可以调大。代码上查看是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗。\n\n设置参数\n```\n-Xms设置堆的最小空间大小。\n\n-Xmx设置堆的最大空间大小。\n\n-XX:+HeapDumpOnOutOfMemoryError:出现内存溢出Dump出当前内存堆转储快照，以便事后分析\n```\n\n\n- <font color='red'>栈</font>\n\n栈的容量通过 -Xss 参数设置，java虚拟机描述了两种异常：\n\n+ 线程请求的栈深度大于虚拟机有允许的最大深度，抛出 StackOverflowError异常。\n+ 虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OutOfMemoryError异常。\n\n\n\n\n\n\n\n\n\n\n\n\n```\n-Xms设置堆的最小空间大小。\n\n-Xmx设置堆的最大空间大小。\n\n-XX:NewSize设置新生代最小空间大小。\n\n-XX:MaxNewSize设置新生代最大空间大小。\n\n-XX:PermSize设置永久代最小空间大小。\n\n-XX:MaxPermSize设置永久代最大空间大小。\n\n-Xss设置每个线程的堆栈大小。\n\n-XX:MetaSpaceSize: 设置元空间大小\n\n-XX:+PrintGCDetails: 打印GC详细日志\n\n-XX:SurvivorRatio: 设置新生代中Eden区和s0、s1的大小占比，默认-XX:SurvivorRatio=8,Eden:s0:s1=8:1:1\n\n-XX:MaxTenuringThreshold: 设置进入老年代的年龄\n\n-XX:+DisableExplicitGC。这个参数的意思就是禁止显式执行GC，不允许你来通过代码触发GC\n\n\n-XX:CMSFullGCsBeforeCompaction=5 设置FULL GC多少次之后进行内存整理\n\n-XX:+HeapDumpOnOutOfMemoryError 内存溢出自动dump\n-XX:HeapDumpPath=./ dump路径\n-Xloggc:gc.log  打印GC日志\n-XX:+PrintGCDetails  打印GC日志细节\n-XX:+UseParNewGC  使用parNew垃圾收集器\n-XX:+UseConcMarkSweepGC 使用CMS垃圾收集器\n```\n没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。\n\n```\n老年代空间大小=堆空间大小-年轻代大空间大小\n```\n\n","source":"_posts/jvm/java-jvm-1.md","raw":"---\ntitle: JVM学习笔记-运行时数据区域\ndate: 2019-05-21 15:35:37\ncategories: \n    - JAVA_JVM\ntags: \n    - JVM\n---\n\n\n&#160; &#160; &#160; &#160;​java虚拟机在运行java程序的时候，会将内存划分成不同的数据区域，每个区域负责不同的功能，通常分为：方法区、虚拟机栈、本地方法栈。接下来我们一一介绍这些概念。\n\n![jvm_area.png](./jvm_area.png)\n\n\n### 1.程序计数器\n\n&#160; &#160; &#160; &#160;​程序计数器是一块非常小的内存，它是当前线程所执行的字节码的行号指示器。在虚拟机的概念里，字节码解释器是通过改变这个计数器的值来选取下一个需要执行的字节码指令， 分支、循环、异常处理、线程恢复都依赖这个程序计数器来完成。\n&#160; &#160; &#160; &#160;java多线程执行是通过不停切换处理器来分别执行各个线程实现的，也就是同一时刻只有一个处理器只能执行一条线程，每个线程执行一段时间在执行其他的线程，所以每个线程都需要有自己独立的程序计数器，才能在处理器切回自己线程的时候，继续正确执行，所以**程序计时器是线程私有的**。\n&#160; &#160; &#160; &#160;程序计数器是java虚拟机唯一一个没有OutOfMemoryError的区域。\n\n### 2.java虚拟机栈\n\n&#160; &#160; &#160; &#160;java虚拟机栈描述的是java方法执行的内存模型，每个方法执行的时候，会在创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等。同时栈是线程私有的，生命周期与线程相同。\n&#160; &#160; &#160; &#160;局部变量表存放了编译器可知的各种基本数据类型（boolean，byte，char,short,int,float,long,double）、对象引用和returnAddress类型。\n&#160; &#160; &#160; &#160;64位长度的long和double类型的数据会占用两个局部变量的空间，其余的数据类型都只占用1个空间。局部变量表需要的空间，在编译期间完成分配，当进入一个方法时，这个方法需要的在栈分配的大小是完全确定的在方法运行时，局部变量表的大小不会改变。\n&#160; &#160; &#160; &#160;这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverFlowError异常。如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。\n\n\n\n### 3.本地方法栈\n\n&#160; &#160; &#160; &#160;本地方法栈与java虚拟机栈非常相似，虚拟机栈为java方法服务，而本地方法栈为Native方法服务。\n\n### 4.java堆\n\n&#160; &#160; &#160; &#160;堆是java虚拟机管理的最大的一块内存。在虚拟机启动的时候创建，并且是线程共享的。java堆主要用于存放对象实例。几乎所有的对象实例都在这里分配内存。\n&#160; &#160; &#160; &#160;​java堆也是垃圾收集器主要处理的区域。很多时候也被叫做“GC堆”，从内存回收的角度来看，现在收集器基本都采用分代收集法，所有java堆可以细分为新生代和老年代，在细分一点就是Eden空间、From Survivor空间、To Survivor空间。\n&#160; &#160; &#160; &#160;根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。\n\n&#160; &#160; &#160; &#160;如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。\n\n\n### 5.方法区\n\n&#160; &#160; &#160; &#160;方法区是线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。java虚拟机规范吧方法区描述为堆的一个逻辑部分，但是他也有一个别名Non-Heap(非堆)。目的与java堆分区开。\n&#160; &#160; &#160; &#160;习惯HotSpot虚拟机的开发者，更愿意把方法区成为“永久代”，本质上两种不等价，仅仅因为HotSpot虚拟机的设计团队选择吧GC分代收集扩展到方法区。或者说永久代来实现方法区而已。这样HotSpot的垃圾收集器可以向管理java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。\n&#160; &#160; &#160; &#160;java虚拟机堆方法区的限制非常宽松，不需要联系的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域比较少出现，但是并非数据进入了方法区就不收集了。这个区域内存回收的主要目标是针对常量池的回收和对类型的卸载。一般这个区域回收条件比较苛刻，但是回收还是有必要的。\n&#160; &#160; &#160; &#160;当方法区无法申请到足够的内存的时候，也会抛出OutOfMemoryError异常。\n\n### 6.运行时常量池\n\n&#160; &#160; &#160; &#160; 方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。在常量池无法在申请到内存会抛出OutOfMemoryError。\n&#160; &#160; &#160; &#160;运行时常量池有一个重要的特征-具备动态性。java语言不要求常量一定只有在编译器才能产生，运行期间也可以能将新的常量放在池中，这种特性被开发人员利用比较多的便是String类的intern()方法。\n\n\n### 7.加课：OutOfMemoryError异常\n\n- <font color='red'>堆</font>\n\njava堆用于存储对象实例，只要不断创建对象，并且保证 GC Roots 到对象之间有可达路径，对象数量达到最大堆的容量限制就会产生内存溢出异常。\n\n堆抛出 java.lang.OutOfMemoryError会进一步提示 java heap space.\n\n要解决堆异常，一般需要通过内存映像分析工具对Dump处理的堆转储快照进行分析，重点是确定内存中对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。\n\n如果内存泄漏，通过工具查看泄漏对象到GC Roots的引用链。就能找到泄漏对象是通过怎样的路劲与GC Roots相关联并导致垃圾收集器无法自动回收他们的，掌握了泄漏对象的类型信息以及GC Roots引用链的信息，就能比较准确定位泄漏代码的位置。\n\n如果不存在泄漏。检查虚拟机的堆参数与机器物料内存对比，是否还可以调大。代码上查看是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗。\n\n设置参数\n```\n-Xms设置堆的最小空间大小。\n\n-Xmx设置堆的最大空间大小。\n\n-XX:+HeapDumpOnOutOfMemoryError:出现内存溢出Dump出当前内存堆转储快照，以便事后分析\n```\n\n\n- <font color='red'>栈</font>\n\n栈的容量通过 -Xss 参数设置，java虚拟机描述了两种异常：\n\n+ 线程请求的栈深度大于虚拟机有允许的最大深度，抛出 StackOverflowError异常。\n+ 虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OutOfMemoryError异常。\n\n\n\n\n\n\n\n\n\n\n\n\n```\n-Xms设置堆的最小空间大小。\n\n-Xmx设置堆的最大空间大小。\n\n-XX:NewSize设置新生代最小空间大小。\n\n-XX:MaxNewSize设置新生代最大空间大小。\n\n-XX:PermSize设置永久代最小空间大小。\n\n-XX:MaxPermSize设置永久代最大空间大小。\n\n-Xss设置每个线程的堆栈大小。\n\n-XX:MetaSpaceSize: 设置元空间大小\n\n-XX:+PrintGCDetails: 打印GC详细日志\n\n-XX:SurvivorRatio: 设置新生代中Eden区和s0、s1的大小占比，默认-XX:SurvivorRatio=8,Eden:s0:s1=8:1:1\n\n-XX:MaxTenuringThreshold: 设置进入老年代的年龄\n\n-XX:+DisableExplicitGC。这个参数的意思就是禁止显式执行GC，不允许你来通过代码触发GC\n\n\n-XX:CMSFullGCsBeforeCompaction=5 设置FULL GC多少次之后进行内存整理\n\n-XX:+HeapDumpOnOutOfMemoryError 内存溢出自动dump\n-XX:HeapDumpPath=./ dump路径\n-Xloggc:gc.log  打印GC日志\n-XX:+PrintGCDetails  打印GC日志细节\n-XX:+UseParNewGC  使用parNew垃圾收集器\n-XX:+UseConcMarkSweepGC 使用CMS垃圾收集器\n```\n没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。\n\n```\n老年代空间大小=堆空间大小-年轻代大空间大小\n```\n\n","slug":"jvm/java-jvm-1","published":1,"updated":"2020-12-03T02:27:02.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5xzu000154vi8s6z7rdt","content":"<p>&#160; &#160; &#160; &#160;​java虚拟机在运行java程序的时候，会将内存划分成不同的数据区域，每个区域负责不同的功能，通常分为：方法区、虚拟机栈、本地方法栈。接下来我们一一介绍这些概念。</p>\n<p><img src=\"./jvm_area.png\" alt=\"jvm_area.png\"></p>\n<h3 id=\"1-程序计数器\"><a href=\"#1-程序计数器\" class=\"headerlink\" title=\"1.程序计数器\"></a>1.程序计数器</h3><p>&#160; &#160; &#160; &#160;​程序计数器是一块非常小的内存，它是当前线程所执行的字节码的行号指示器。在虚拟机的概念里，字节码解释器是通过改变这个计数器的值来选取下一个需要执行的字节码指令， 分支、循环、异常处理、线程恢复都依赖这个程序计数器来完成。<br>&#160; &#160; &#160; &#160;java多线程执行是通过不停切换处理器来分别执行各个线程实现的，也就是同一时刻只有一个处理器只能执行一条线程，每个线程执行一段时间在执行其他的线程，所以每个线程都需要有自己独立的程序计数器，才能在处理器切回自己线程的时候，继续正确执行，所以<strong>程序计时器是线程私有的</strong>。<br>&#160; &#160; &#160; &#160;程序计数器是java虚拟机唯一一个没有OutOfMemoryError的区域。</p>\n<h3 id=\"2-java虚拟机栈\"><a href=\"#2-java虚拟机栈\" class=\"headerlink\" title=\"2.java虚拟机栈\"></a>2.java虚拟机栈</h3><p>&#160; &#160; &#160; &#160;java虚拟机栈描述的是java方法执行的内存模型，每个方法执行的时候，会在创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等。同时栈是线程私有的，生命周期与线程相同。<br>&#160; &#160; &#160; &#160;局部变量表存放了编译器可知的各种基本数据类型（boolean，byte，char,short,int,float,long,double）、对象引用和returnAddress类型。<br>&#160; &#160; &#160; &#160;64位长度的long和double类型的数据会占用两个局部变量的空间，其余的数据类型都只占用1个空间。局部变量表需要的空间，在编译期间完成分配，当进入一个方法时，这个方法需要的在栈分配的大小是完全确定的在方法运行时，局部变量表的大小不会改变。<br>&#160; &#160; &#160; &#160;这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverFlowError异常。如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。</p>\n<h3 id=\"3-本地方法栈\"><a href=\"#3-本地方法栈\" class=\"headerlink\" title=\"3.本地方法栈\"></a>3.本地方法栈</h3><p>&#160; &#160; &#160; &#160;本地方法栈与java虚拟机栈非常相似，虚拟机栈为java方法服务，而本地方法栈为Native方法服务。</p>\n<h3 id=\"4-java堆\"><a href=\"#4-java堆\" class=\"headerlink\" title=\"4.java堆\"></a>4.java堆</h3><p>&#160; &#160; &#160; &#160;堆是java虚拟机管理的最大的一块内存。在虚拟机启动的时候创建，并且是线程共享的。java堆主要用于存放对象实例。几乎所有的对象实例都在这里分配内存。<br>&#160; &#160; &#160; &#160;​java堆也是垃圾收集器主要处理的区域。很多时候也被叫做“GC堆”，从内存回收的角度来看，现在收集器基本都采用分代收集法，所有java堆可以细分为新生代和老年代，在细分一点就是Eden空间、From Survivor空间、To Survivor空间。<br>&#160; &#160; &#160; &#160;根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p>\n<p>&#160; &#160; &#160; &#160;如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>\n<h3 id=\"5-方法区\"><a href=\"#5-方法区\" class=\"headerlink\" title=\"5.方法区\"></a>5.方法区</h3><p>&#160; &#160; &#160; &#160;方法区是线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。java虚拟机规范吧方法区描述为堆的一个逻辑部分，但是他也有一个别名Non-Heap(非堆)。目的与java堆分区开。<br>&#160; &#160; &#160; &#160;习惯HotSpot虚拟机的开发者，更愿意把方法区成为“永久代”，本质上两种不等价，仅仅因为HotSpot虚拟机的设计团队选择吧GC分代收集扩展到方法区。或者说永久代来实现方法区而已。这样HotSpot的垃圾收集器可以向管理java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。<br>&#160; &#160; &#160; &#160;java虚拟机堆方法区的限制非常宽松，不需要联系的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域比较少出现，但是并非数据进入了方法区就不收集了。这个区域内存回收的主要目标是针对常量池的回收和对类型的卸载。一般这个区域回收条件比较苛刻，但是回收还是有必要的。<br>&#160; &#160; &#160; &#160;当方法区无法申请到足够的内存的时候，也会抛出OutOfMemoryError异常。</p>\n<h3 id=\"6-运行时常量池\"><a href=\"#6-运行时常量池\" class=\"headerlink\" title=\"6.运行时常量池\"></a>6.运行时常量池</h3><p>&#160; &#160; &#160; &#160; 方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。在常量池无法在申请到内存会抛出OutOfMemoryError。<br>&#160; &#160; &#160; &#160;运行时常量池有一个重要的特征-具备动态性。java语言不要求常量一定只有在编译器才能产生，运行期间也可以能将新的常量放在池中，这种特性被开发人员利用比较多的便是String类的intern()方法。</p>\n<h3 id=\"7-加课：OutOfMemoryError异常\"><a href=\"#7-加课：OutOfMemoryError异常\" class=\"headerlink\" title=\"7.加课：OutOfMemoryError异常\"></a>7.加课：OutOfMemoryError异常</h3><ul>\n<li><font color='red'>堆</font></li>\n</ul>\n<p>java堆用于存储对象实例，只要不断创建对象，并且保证 GC Roots 到对象之间有可达路径，对象数量达到最大堆的容量限制就会产生内存溢出异常。</p>\n<p>堆抛出 java.lang.OutOfMemoryError会进一步提示 java heap space.</p>\n<p>要解决堆异常，一般需要通过内存映像分析工具对Dump处理的堆转储快照进行分析，重点是确定内存中对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。</p>\n<p>如果内存泄漏，通过工具查看泄漏对象到GC Roots的引用链。就能找到泄漏对象是通过怎样的路劲与GC Roots相关联并导致垃圾收集器无法自动回收他们的，掌握了泄漏对象的类型信息以及GC Roots引用链的信息，就能比较准确定位泄漏代码的位置。</p>\n<p>如果不存在泄漏。检查虚拟机的堆参数与机器物料内存对比，是否还可以调大。代码上查看是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗。</p>\n<p>设置参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms设置堆的最小空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmx设置堆的最大空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError:出现内存溢出Dump出当前内存堆转储快照，以便事后分析</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><font color='red'>栈</font></li>\n</ul>\n<p>栈的容量通过 -Xss 参数设置，java虚拟机描述了两种异常：</p>\n<ul>\n<li>线程请求的栈深度大于虚拟机有允许的最大深度，抛出 StackOverflowError异常。</li>\n<li>虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OutOfMemoryError异常。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms设置堆的最小空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmx设置堆的最大空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:NewSize设置新生代最小空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxNewSize设置新生代最大空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:PermSize设置永久代最小空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxPermSize设置永久代最大空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-Xss设置每个线程的堆栈大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MetaSpaceSize: 设置元空间大小</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+PrintGCDetails: 打印GC详细日志</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:SurvivorRatio: 设置新生代中Eden区和s0、s1的大小占比，默认-XX:SurvivorRatio&#x3D;8,Eden:s0:s1&#x3D;8:1:1</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxTenuringThreshold: 设置进入老年代的年龄</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+DisableExplicitGC。这个参数的意思就是禁止显式执行GC，不允许你来通过代码触发GC</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-XX:CMSFullGCsBeforeCompaction&#x3D;5 设置FULL GC多少次之后进行内存整理</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError 内存溢出自动dump</span><br><span class=\"line\">-XX:HeapDumpPath&#x3D;.&#x2F; dump路径</span><br><span class=\"line\">-Xloggc:gc.log  打印GC日志</span><br><span class=\"line\">-XX:+PrintGCDetails  打印GC日志细节</span><br><span class=\"line\">-XX:+UseParNewGC  使用parNew垃圾收集器</span><br><span class=\"line\">-XX:+UseConcMarkSweepGC 使用CMS垃圾收集器</span><br></pre></td></tr></table></figure>\n<p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">老年代空间大小&#x3D;堆空间大小-年轻代大空间大小</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>&#160; &#160; &#160; &#160;​java虚拟机在运行java程序的时候，会将内存划分成不同的数据区域，每个区域负责不同的功能，通常分为：方法区、虚拟机栈、本地方法栈。接下来我们一一介绍这些概念。</p>\n<p><img src=\"./jvm_area.png\" alt=\"jvm_area.png\"></p>\n<h3 id=\"1-程序计数器\"><a href=\"#1-程序计数器\" class=\"headerlink\" title=\"1.程序计数器\"></a>1.程序计数器</h3><p>&#160; &#160; &#160; &#160;​程序计数器是一块非常小的内存，它是当前线程所执行的字节码的行号指示器。在虚拟机的概念里，字节码解释器是通过改变这个计数器的值来选取下一个需要执行的字节码指令， 分支、循环、异常处理、线程恢复都依赖这个程序计数器来完成。<br>&#160; &#160; &#160; &#160;java多线程执行是通过不停切换处理器来分别执行各个线程实现的，也就是同一时刻只有一个处理器只能执行一条线程，每个线程执行一段时间在执行其他的线程，所以每个线程都需要有自己独立的程序计数器，才能在处理器切回自己线程的时候，继续正确执行，所以<strong>程序计时器是线程私有的</strong>。<br>&#160; &#160; &#160; &#160;程序计数器是java虚拟机唯一一个没有OutOfMemoryError的区域。</p>\n<h3 id=\"2-java虚拟机栈\"><a href=\"#2-java虚拟机栈\" class=\"headerlink\" title=\"2.java虚拟机栈\"></a>2.java虚拟机栈</h3><p>&#160; &#160; &#160; &#160;java虚拟机栈描述的是java方法执行的内存模型，每个方法执行的时候，会在创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等。同时栈是线程私有的，生命周期与线程相同。<br>&#160; &#160; &#160; &#160;局部变量表存放了编译器可知的各种基本数据类型（boolean，byte，char,short,int,float,long,double）、对象引用和returnAddress类型。<br>&#160; &#160; &#160; &#160;64位长度的long和double类型的数据会占用两个局部变量的空间，其余的数据类型都只占用1个空间。局部变量表需要的空间，在编译期间完成分配，当进入一个方法时，这个方法需要的在栈分配的大小是完全确定的在方法运行时，局部变量表的大小不会改变。<br>&#160; &#160; &#160; &#160;这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverFlowError异常。如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。</p>\n<h3 id=\"3-本地方法栈\"><a href=\"#3-本地方法栈\" class=\"headerlink\" title=\"3.本地方法栈\"></a>3.本地方法栈</h3><p>&#160; &#160; &#160; &#160;本地方法栈与java虚拟机栈非常相似，虚拟机栈为java方法服务，而本地方法栈为Native方法服务。</p>\n<h3 id=\"4-java堆\"><a href=\"#4-java堆\" class=\"headerlink\" title=\"4.java堆\"></a>4.java堆</h3><p>&#160; &#160; &#160; &#160;堆是java虚拟机管理的最大的一块内存。在虚拟机启动的时候创建，并且是线程共享的。java堆主要用于存放对象实例。几乎所有的对象实例都在这里分配内存。<br>&#160; &#160; &#160; &#160;​java堆也是垃圾收集器主要处理的区域。很多时候也被叫做“GC堆”，从内存回收的角度来看，现在收集器基本都采用分代收集法，所有java堆可以细分为新生代和老年代，在细分一点就是Eden空间、From Survivor空间、To Survivor空间。<br>&#160; &#160; &#160; &#160;根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p>\n<p>&#160; &#160; &#160; &#160;如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>\n<h3 id=\"5-方法区\"><a href=\"#5-方法区\" class=\"headerlink\" title=\"5.方法区\"></a>5.方法区</h3><p>&#160; &#160; &#160; &#160;方法区是线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。java虚拟机规范吧方法区描述为堆的一个逻辑部分，但是他也有一个别名Non-Heap(非堆)。目的与java堆分区开。<br>&#160; &#160; &#160; &#160;习惯HotSpot虚拟机的开发者，更愿意把方法区成为“永久代”，本质上两种不等价，仅仅因为HotSpot虚拟机的设计团队选择吧GC分代收集扩展到方法区。或者说永久代来实现方法区而已。这样HotSpot的垃圾收集器可以向管理java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。<br>&#160; &#160; &#160; &#160;java虚拟机堆方法区的限制非常宽松，不需要联系的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域比较少出现，但是并非数据进入了方法区就不收集了。这个区域内存回收的主要目标是针对常量池的回收和对类型的卸载。一般这个区域回收条件比较苛刻，但是回收还是有必要的。<br>&#160; &#160; &#160; &#160;当方法区无法申请到足够的内存的时候，也会抛出OutOfMemoryError异常。</p>\n<h3 id=\"6-运行时常量池\"><a href=\"#6-运行时常量池\" class=\"headerlink\" title=\"6.运行时常量池\"></a>6.运行时常量池</h3><p>&#160; &#160; &#160; &#160; 方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。在常量池无法在申请到内存会抛出OutOfMemoryError。<br>&#160; &#160; &#160; &#160;运行时常量池有一个重要的特征-具备动态性。java语言不要求常量一定只有在编译器才能产生，运行期间也可以能将新的常量放在池中，这种特性被开发人员利用比较多的便是String类的intern()方法。</p>\n<h3 id=\"7-加课：OutOfMemoryError异常\"><a href=\"#7-加课：OutOfMemoryError异常\" class=\"headerlink\" title=\"7.加课：OutOfMemoryError异常\"></a>7.加课：OutOfMemoryError异常</h3><ul>\n<li><font color='red'>堆</font></li>\n</ul>\n<p>java堆用于存储对象实例，只要不断创建对象，并且保证 GC Roots 到对象之间有可达路径，对象数量达到最大堆的容量限制就会产生内存溢出异常。</p>\n<p>堆抛出 java.lang.OutOfMemoryError会进一步提示 java heap space.</p>\n<p>要解决堆异常，一般需要通过内存映像分析工具对Dump处理的堆转储快照进行分析，重点是确定内存中对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。</p>\n<p>如果内存泄漏，通过工具查看泄漏对象到GC Roots的引用链。就能找到泄漏对象是通过怎样的路劲与GC Roots相关联并导致垃圾收集器无法自动回收他们的，掌握了泄漏对象的类型信息以及GC Roots引用链的信息，就能比较准确定位泄漏代码的位置。</p>\n<p>如果不存在泄漏。检查虚拟机的堆参数与机器物料内存对比，是否还可以调大。代码上查看是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗。</p>\n<p>设置参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms设置堆的最小空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmx设置堆的最大空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError:出现内存溢出Dump出当前内存堆转储快照，以便事后分析</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><font color='red'>栈</font></li>\n</ul>\n<p>栈的容量通过 -Xss 参数设置，java虚拟机描述了两种异常：</p>\n<ul>\n<li>线程请求的栈深度大于虚拟机有允许的最大深度，抛出 StackOverflowError异常。</li>\n<li>虚拟机在扩展栈时无法申请到足够的内存空间，则会抛出OutOfMemoryError异常。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms设置堆的最小空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-Xmx设置堆的最大空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:NewSize设置新生代最小空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxNewSize设置新生代最大空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:PermSize设置永久代最小空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxPermSize设置永久代最大空间大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-Xss设置每个线程的堆栈大小。</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MetaSpaceSize: 设置元空间大小</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+PrintGCDetails: 打印GC详细日志</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:SurvivorRatio: 设置新生代中Eden区和s0、s1的大小占比，默认-XX:SurvivorRatio&#x3D;8,Eden:s0:s1&#x3D;8:1:1</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:MaxTenuringThreshold: 设置进入老年代的年龄</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+DisableExplicitGC。这个参数的意思就是禁止显式执行GC，不允许你来通过代码触发GC</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-XX:CMSFullGCsBeforeCompaction&#x3D;5 设置FULL GC多少次之后进行内存整理</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError 内存溢出自动dump</span><br><span class=\"line\">-XX:HeapDumpPath&#x3D;.&#x2F; dump路径</span><br><span class=\"line\">-Xloggc:gc.log  打印GC日志</span><br><span class=\"line\">-XX:+PrintGCDetails  打印GC日志细节</span><br><span class=\"line\">-XX:+UseParNewGC  使用parNew垃圾收集器</span><br><span class=\"line\">-XX:+UseConcMarkSweepGC 使用CMS垃圾收集器</span><br></pre></td></tr></table></figure>\n<p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">老年代空间大小&#x3D;堆空间大小-年轻代大空间大小</span><br></pre></td></tr></table></figure>\n\n"},{"title":"java 性能监控与故障处理工具","date":"2019-05-28T09:44:35.000Z","_content":"\n## 1.JDK命令工具\n\n名称|主要作用\n:-|:-\njps|JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程\njstat|JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据\njinfo|Configuration Info For Java ,显示虚拟机配置信息\njmap|Memory Map For Java,生成虚拟机的内存转储快照\njhat|JVM Heap Dump Browser,用于分析heapdump文件，它会建立一个Http/HTML服务器，让用户可以在浏览器上查看分析结果\njstack|Stack Trace For Java 显示虚拟机的线程快照\n\n### 1.1 jps:虚拟机进程状态工具\njps列出正在运行的虚拟机进行，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。\n\njps命令:\n```\njps [option] [hostid]\n```\n\njps执行样例:\n![jps.png](./jps.png)\n\n选项|作用\n:-|:-\n-q|只输出LVMID，省略主类的名称\n-m|输出虚拟机进程启动是传递给主类main()函数的参数\n-l|输出主类的全名，如果进程执行的是jar包，输出jar路径\n-v|输出虚拟机进程启动时JVM参数\n\n### 1.2 jstat:虚拟机统计信息监视工具\n\njstat监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。\n\njstat命令格式\n```\njstat [option vmid [interval[s|ms][count]]]\n```\nvmid:\n本地：与本地VMID一致。\n远程：格式如下\n[protocol:][//]lvmid[@hostname[:port]/servername]\n\ninterval:查询间隔。\ncount：次数。\n\n如果省略两个参数，说明只查询一次。\n\n```\n每250秒查询一次进行2777垃圾收集状况，一次查询20次\njstat -gc 2777 250 20\n```\n\noption:查询虚拟机信息，分为3类：类装载、垃圾收集、运行编译状况\n\n选项|作用\n-|-\n-class|监视类装载。卸载数量、总空间以及类装载所消耗的时间\n-gc|监视java堆状况，包括Eden区、两个Survivor区、老年代、永久代等容量、已用空间、GC时间合计等信息\n-gccapacity|监视内容与-gc基本相同，但是输出主要关注java堆各个区域使用的最大、最小空间\n-gcutil|监视内容与-gc基本相同，但是输出主要关注已使用的空间占总空间的百分比\n-gccause|与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因\n-gcnew|监视新生代GC状况\n-gcnewcapacity|监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间\n-gcold|监视老年代GC状况\n-gcoldcapacity|监视内容与-gcold相同，输出主要关注使用到的最大、最小空间\n-gcpermcapacity|输出永久代使用到的最大、最小空间\n-compiler|输出JIT编译器编译过的方法和耗时等信息\n-printcompilation|输出已近被JIT编译方法\n\n\n### 1.3 jinfo:java配置信息工具\n\njinfo的作用是实时的查看和调整虚拟机各项参数\n\njinfo命令\n```\njinfo [option] pid\n```\n\n### 1.4 jmap:java内存印象工具\n\njmap用于生成堆转储快照（heapdump/dump文件）。还可以查询finalize执行队列、java堆和永久代的详细信息，如空间使用率、当前用的哪种收集器等。\n\njmap命令\n```\njmap [option] vmid\n```\n选项|作用\n-|-\n-dump|生成java堆转储快照，格式为-dump:[live,]format=b,file=<filename\\>,其中live子参数说明是否只dump出存活的对象\n-finalizerinfo|显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效\n-heap|显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效\n-histo|显示堆中对象统计信息，包括类、实例数量、合计容量\n-permstat|以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效\n-F|当虚拟机进程堆-dump选项没有响应时，可以使用这个选项强制生成dump快照。只在Linux/Solaris\n平台下有效\n\n### 1.5 jhat:虚拟机堆转储快照分析工具\n\njhat用于生成虚拟机当前时刻快照。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等。\n\njstack命令\n```\njstack [option] vmid\n```\n\n选项|作用\n-|-\n-F|当正常输出的请求不被响应时，强制输出线程堆栈\n-l|除堆栈外，显示关于锁的附加信息\n-m|如果调用本地方法的话，可以显示c/c++的堆栈","source":"_posts/jvm/java-jvm-monitor.md","raw":"---\ntitle: java 性能监控与故障处理工具\ndate: 2019-05-28 17:44:35\ncategories: \n    - JAVA_JVM\ntags: \n    - JVM\n---\n\n## 1.JDK命令工具\n\n名称|主要作用\n:-|:-\njps|JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程\njstat|JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据\njinfo|Configuration Info For Java ,显示虚拟机配置信息\njmap|Memory Map For Java,生成虚拟机的内存转储快照\njhat|JVM Heap Dump Browser,用于分析heapdump文件，它会建立一个Http/HTML服务器，让用户可以在浏览器上查看分析结果\njstack|Stack Trace For Java 显示虚拟机的线程快照\n\n### 1.1 jps:虚拟机进程状态工具\njps列出正在运行的虚拟机进行，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。\n\njps命令:\n```\njps [option] [hostid]\n```\n\njps执行样例:\n![jps.png](./jps.png)\n\n选项|作用\n:-|:-\n-q|只输出LVMID，省略主类的名称\n-m|输出虚拟机进程启动是传递给主类main()函数的参数\n-l|输出主类的全名，如果进程执行的是jar包，输出jar路径\n-v|输出虚拟机进程启动时JVM参数\n\n### 1.2 jstat:虚拟机统计信息监视工具\n\njstat监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。\n\njstat命令格式\n```\njstat [option vmid [interval[s|ms][count]]]\n```\nvmid:\n本地：与本地VMID一致。\n远程：格式如下\n[protocol:][//]lvmid[@hostname[:port]/servername]\n\ninterval:查询间隔。\ncount：次数。\n\n如果省略两个参数，说明只查询一次。\n\n```\n每250秒查询一次进行2777垃圾收集状况，一次查询20次\njstat -gc 2777 250 20\n```\n\noption:查询虚拟机信息，分为3类：类装载、垃圾收集、运行编译状况\n\n选项|作用\n-|-\n-class|监视类装载。卸载数量、总空间以及类装载所消耗的时间\n-gc|监视java堆状况，包括Eden区、两个Survivor区、老年代、永久代等容量、已用空间、GC时间合计等信息\n-gccapacity|监视内容与-gc基本相同，但是输出主要关注java堆各个区域使用的最大、最小空间\n-gcutil|监视内容与-gc基本相同，但是输出主要关注已使用的空间占总空间的百分比\n-gccause|与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因\n-gcnew|监视新生代GC状况\n-gcnewcapacity|监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间\n-gcold|监视老年代GC状况\n-gcoldcapacity|监视内容与-gcold相同，输出主要关注使用到的最大、最小空间\n-gcpermcapacity|输出永久代使用到的最大、最小空间\n-compiler|输出JIT编译器编译过的方法和耗时等信息\n-printcompilation|输出已近被JIT编译方法\n\n\n### 1.3 jinfo:java配置信息工具\n\njinfo的作用是实时的查看和调整虚拟机各项参数\n\njinfo命令\n```\njinfo [option] pid\n```\n\n### 1.4 jmap:java内存印象工具\n\njmap用于生成堆转储快照（heapdump/dump文件）。还可以查询finalize执行队列、java堆和永久代的详细信息，如空间使用率、当前用的哪种收集器等。\n\njmap命令\n```\njmap [option] vmid\n```\n选项|作用\n-|-\n-dump|生成java堆转储快照，格式为-dump:[live,]format=b,file=<filename\\>,其中live子参数说明是否只dump出存活的对象\n-finalizerinfo|显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效\n-heap|显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效\n-histo|显示堆中对象统计信息，包括类、实例数量、合计容量\n-permstat|以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效\n-F|当虚拟机进程堆-dump选项没有响应时，可以使用这个选项强制生成dump快照。只在Linux/Solaris\n平台下有效\n\n### 1.5 jhat:虚拟机堆转储快照分析工具\n\njhat用于生成虚拟机当前时刻快照。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等。\n\njstack命令\n```\njstack [option] vmid\n```\n\n选项|作用\n-|-\n-F|当正常输出的请求不被响应时，强制输出线程堆栈\n-l|除堆栈外，显示关于锁的附加信息\n-m|如果调用本地方法的话，可以显示c/c++的堆栈","slug":"jvm/java-jvm-monitor","published":1,"updated":"2020-11-03T16:13:26.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5xzy000354vi586a6y9t","content":"<h2 id=\"1-JDK命令工具\"><a href=\"#1-JDK命令工具\" class=\"headerlink\" title=\"1.JDK命令工具\"></a>1.JDK命令工具</h2><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">主要作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">jps</td>\n<td align=\"left\">JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</td>\n</tr>\n<tr>\n<td align=\"left\">jstat</td>\n<td align=\"left\">JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据</td>\n</tr>\n<tr>\n<td align=\"left\">jinfo</td>\n<td align=\"left\">Configuration Info For Java ,显示虚拟机配置信息</td>\n</tr>\n<tr>\n<td align=\"left\">jmap</td>\n<td align=\"left\">Memory Map For Java,生成虚拟机的内存转储快照</td>\n</tr>\n<tr>\n<td align=\"left\">jhat</td>\n<td align=\"left\">JVM Heap Dump Browser,用于分析heapdump文件，它会建立一个Http/HTML服务器，让用户可以在浏览器上查看分析结果</td>\n</tr>\n<tr>\n<td align=\"left\">jstack</td>\n<td align=\"left\">Stack Trace For Java 显示虚拟机的线程快照</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-1-jps-虚拟机进程状态工具\"><a href=\"#1-1-jps-虚拟机进程状态工具\" class=\"headerlink\" title=\"1.1 jps:虚拟机进程状态工具\"></a>1.1 jps:虚拟机进程状态工具</h3><p>jps列出正在运行的虚拟机进行，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。</p>\n<p>jps命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps [option] [hostid]</span><br></pre></td></tr></table></figure>\n\n<p>jps执行样例:<br><img src=\"./jps.png\" alt=\"jps.png\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-q</td>\n<td align=\"left\">只输出LVMID，省略主类的名称</td>\n</tr>\n<tr>\n<td align=\"left\">-m</td>\n<td align=\"left\">输出虚拟机进程启动是传递给主类main()函数的参数</td>\n</tr>\n<tr>\n<td align=\"left\">-l</td>\n<td align=\"left\">输出主类的全名，如果进程执行的是jar包，输出jar路径</td>\n</tr>\n<tr>\n<td align=\"left\">-v</td>\n<td align=\"left\">输出虚拟机进程启动时JVM参数</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-2-jstat-虚拟机统计信息监视工具\"><a href=\"#1-2-jstat-虚拟机统计信息监视工具\" class=\"headerlink\" title=\"1.2 jstat:虚拟机统计信息监视工具\"></a>1.2 jstat:虚拟机统计信息监视工具</h3><p>jstat监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>\n<p>jstat命令格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat [option vmid [interval[s|ms][count]]]</span><br></pre></td></tr></table></figure>\n<p>vmid:<br>本地：与本地VMID一致。<br>远程：格式如下<br>[protocol:][//]lvmid[@hostname[:port]/servername]</p>\n<p>interval:查询间隔。<br>count：次数。</p>\n<p>如果省略两个参数，说明只查询一次。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每250秒查询一次进行2777垃圾收集状况，一次查询20次</span><br><span class=\"line\">jstat -gc 2777 250 20</span><br></pre></td></tr></table></figure>\n\n<p>option:查询虚拟机信息，分为3类：类装载、垃圾收集、运行编译状况</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-class</td>\n<td>监视类装载。卸载数量、总空间以及类装载所消耗的时间</td>\n</tr>\n<tr>\n<td>-gc</td>\n<td>监视java堆状况，包括Eden区、两个Survivor区、老年代、永久代等容量、已用空间、GC时间合计等信息</td>\n</tr>\n<tr>\n<td>-gccapacity</td>\n<td>监视内容与-gc基本相同，但是输出主要关注java堆各个区域使用的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcutil</td>\n<td>监视内容与-gc基本相同，但是输出主要关注已使用的空间占总空间的百分比</td>\n</tr>\n<tr>\n<td>-gccause</td>\n<td>与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>\n</tr>\n<tr>\n<td>-gcnew</td>\n<td>监视新生代GC状况</td>\n</tr>\n<tr>\n<td>-gcnewcapacity</td>\n<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcold</td>\n<td>监视老年代GC状况</td>\n</tr>\n<tr>\n<td>-gcoldcapacity</td>\n<td>监视内容与-gcold相同，输出主要关注使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcpermcapacity</td>\n<td>输出永久代使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-compiler</td>\n<td>输出JIT编译器编译过的方法和耗时等信息</td>\n</tr>\n<tr>\n<td>-printcompilation</td>\n<td>输出已近被JIT编译方法</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-3-jinfo-java配置信息工具\"><a href=\"#1-3-jinfo-java配置信息工具\" class=\"headerlink\" title=\"1.3 jinfo:java配置信息工具\"></a>1.3 jinfo:java配置信息工具</h3><p>jinfo的作用是实时的查看和调整虚拟机各项参数</p>\n<p>jinfo命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [option] pid</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-jmap-java内存印象工具\"><a href=\"#1-4-jmap-java内存印象工具\" class=\"headerlink\" title=\"1.4 jmap:java内存印象工具\"></a>1.4 jmap:java内存印象工具</h3><p>jmap用于生成堆转储快照（heapdump/dump文件）。还可以查询finalize执行队列、java堆和永久代的详细信息，如空间使用率、当前用的哪种收集器等。</p>\n<p>jmap命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap [option] vmid</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-dump</td>\n<td>生成java堆转储快照，格式为-dump:[live,]format=b,file=&lt;filename&gt;,其中live子参数说明是否只dump出存活的对象</td>\n</tr>\n<tr>\n<td>-finalizerinfo</td>\n<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效</td>\n</tr>\n<tr>\n<td>-heap</td>\n<td>显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效</td>\n</tr>\n<tr>\n<td>-histo</td>\n<td>显示堆中对象统计信息，包括类、实例数量、合计容量</td>\n</tr>\n<tr>\n<td>-permstat</td>\n<td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>当虚拟机进程堆-dump选项没有响应时，可以使用这个选项强制生成dump快照。只在Linux/Solaris</td>\n</tr>\n<tr>\n<td>平台下有效</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"1-5-jhat-虚拟机堆转储快照分析工具\"><a href=\"#1-5-jhat-虚拟机堆转储快照分析工具\" class=\"headerlink\" title=\"1.5 jhat:虚拟机堆转储快照分析工具\"></a>1.5 jhat:虚拟机堆转储快照分析工具</h3><p>jhat用于生成虚拟机当前时刻快照。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等。</p>\n<p>jstack命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack [option] vmid</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-F</td>\n<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>除堆栈外，显示关于锁的附加信息</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>如果调用本地方法的话，可以显示c/c++的堆栈</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-JDK命令工具\"><a href=\"#1-JDK命令工具\" class=\"headerlink\" title=\"1.JDK命令工具\"></a>1.JDK命令工具</h2><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">主要作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">jps</td>\n<td align=\"left\">JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</td>\n</tr>\n<tr>\n<td align=\"left\">jstat</td>\n<td align=\"left\">JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据</td>\n</tr>\n<tr>\n<td align=\"left\">jinfo</td>\n<td align=\"left\">Configuration Info For Java ,显示虚拟机配置信息</td>\n</tr>\n<tr>\n<td align=\"left\">jmap</td>\n<td align=\"left\">Memory Map For Java,生成虚拟机的内存转储快照</td>\n</tr>\n<tr>\n<td align=\"left\">jhat</td>\n<td align=\"left\">JVM Heap Dump Browser,用于分析heapdump文件，它会建立一个Http/HTML服务器，让用户可以在浏览器上查看分析结果</td>\n</tr>\n<tr>\n<td align=\"left\">jstack</td>\n<td align=\"left\">Stack Trace For Java 显示虚拟机的线程快照</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-1-jps-虚拟机进程状态工具\"><a href=\"#1-1-jps-虚拟机进程状态工具\" class=\"headerlink\" title=\"1.1 jps:虚拟机进程状态工具\"></a>1.1 jps:虚拟机进程状态工具</h3><p>jps列出正在运行的虚拟机进行，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。</p>\n<p>jps命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps [option] [hostid]</span><br></pre></td></tr></table></figure>\n\n<p>jps执行样例:<br><img src=\"./jps.png\" alt=\"jps.png\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-q</td>\n<td align=\"left\">只输出LVMID，省略主类的名称</td>\n</tr>\n<tr>\n<td align=\"left\">-m</td>\n<td align=\"left\">输出虚拟机进程启动是传递给主类main()函数的参数</td>\n</tr>\n<tr>\n<td align=\"left\">-l</td>\n<td align=\"left\">输出主类的全名，如果进程执行的是jar包，输出jar路径</td>\n</tr>\n<tr>\n<td align=\"left\">-v</td>\n<td align=\"left\">输出虚拟机进程启动时JVM参数</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-2-jstat-虚拟机统计信息监视工具\"><a href=\"#1-2-jstat-虚拟机统计信息监视工具\" class=\"headerlink\" title=\"1.2 jstat:虚拟机统计信息监视工具\"></a>1.2 jstat:虚拟机统计信息监视工具</h3><p>jstat监视虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>\n<p>jstat命令格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat [option vmid [interval[s|ms][count]]]</span><br></pre></td></tr></table></figure>\n<p>vmid:<br>本地：与本地VMID一致。<br>远程：格式如下<br>[protocol:][//]lvmid[@hostname[:port]/servername]</p>\n<p>interval:查询间隔。<br>count：次数。</p>\n<p>如果省略两个参数，说明只查询一次。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每250秒查询一次进行2777垃圾收集状况，一次查询20次</span><br><span class=\"line\">jstat -gc 2777 250 20</span><br></pre></td></tr></table></figure>\n\n<p>option:查询虚拟机信息，分为3类：类装载、垃圾收集、运行编译状况</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-class</td>\n<td>监视类装载。卸载数量、总空间以及类装载所消耗的时间</td>\n</tr>\n<tr>\n<td>-gc</td>\n<td>监视java堆状况，包括Eden区、两个Survivor区、老年代、永久代等容量、已用空间、GC时间合计等信息</td>\n</tr>\n<tr>\n<td>-gccapacity</td>\n<td>监视内容与-gc基本相同，但是输出主要关注java堆各个区域使用的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcutil</td>\n<td>监视内容与-gc基本相同，但是输出主要关注已使用的空间占总空间的百分比</td>\n</tr>\n<tr>\n<td>-gccause</td>\n<td>与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>\n</tr>\n<tr>\n<td>-gcnew</td>\n<td>监视新生代GC状况</td>\n</tr>\n<tr>\n<td>-gcnewcapacity</td>\n<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcold</td>\n<td>监视老年代GC状况</td>\n</tr>\n<tr>\n<td>-gcoldcapacity</td>\n<td>监视内容与-gcold相同，输出主要关注使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-gcpermcapacity</td>\n<td>输出永久代使用到的最大、最小空间</td>\n</tr>\n<tr>\n<td>-compiler</td>\n<td>输出JIT编译器编译过的方法和耗时等信息</td>\n</tr>\n<tr>\n<td>-printcompilation</td>\n<td>输出已近被JIT编译方法</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-3-jinfo-java配置信息工具\"><a href=\"#1-3-jinfo-java配置信息工具\" class=\"headerlink\" title=\"1.3 jinfo:java配置信息工具\"></a>1.3 jinfo:java配置信息工具</h3><p>jinfo的作用是实时的查看和调整虚拟机各项参数</p>\n<p>jinfo命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [option] pid</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-jmap-java内存印象工具\"><a href=\"#1-4-jmap-java内存印象工具\" class=\"headerlink\" title=\"1.4 jmap:java内存印象工具\"></a>1.4 jmap:java内存印象工具</h3><p>jmap用于生成堆转储快照（heapdump/dump文件）。还可以查询finalize执行队列、java堆和永久代的详细信息，如空间使用率、当前用的哪种收集器等。</p>\n<p>jmap命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap [option] vmid</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-dump</td>\n<td>生成java堆转储快照，格式为-dump:[live,]format=b,file=&lt;filename&gt;,其中live子参数说明是否只dump出存活的对象</td>\n</tr>\n<tr>\n<td>-finalizerinfo</td>\n<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效</td>\n</tr>\n<tr>\n<td>-heap</td>\n<td>显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效</td>\n</tr>\n<tr>\n<td>-histo</td>\n<td>显示堆中对象统计信息，包括类、实例数量、合计容量</td>\n</tr>\n<tr>\n<td>-permstat</td>\n<td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>\n</tr>\n<tr>\n<td>-F</td>\n<td>当虚拟机进程堆-dump选项没有响应时，可以使用这个选项强制生成dump快照。只在Linux/Solaris</td>\n</tr>\n<tr>\n<td>平台下有效</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"1-5-jhat-虚拟机堆转储快照分析工具\"><a href=\"#1-5-jhat-虚拟机堆转储快照分析工具\" class=\"headerlink\" title=\"1.5 jhat:虚拟机堆转储快照分析工具\"></a>1.5 jhat:虚拟机堆转储快照分析工具</h3><p>jhat用于生成虚拟机当前时刻快照。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等。</p>\n<p>jstack命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack [option] vmid</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-F</td>\n<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>除堆栈外，显示关于锁的附加信息</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>如果调用本地方法的话，可以显示c/c++的堆栈</td>\n</tr>\n</tbody></table>\n"},{"title":"垃圾回收器算法的实现","date":"2019-05-27T07:49:28.000Z","_content":"\n## HOTSPOT算法实现\n### 枚举根节点\n\nGC Roots主要在全局性的引用（例如常量或者类静态属性）与执行上下文（例如栈帧中的本地变量表）中，java进行可达性分析时，对执行时间的敏感还体现在GC停顿上，因为分析工作必须在一个能确保一致性（分析过程中对象引用关系不能再不断变化）的快照中进行，这点是导致GC进行时必须停顿所有的java执行线程的一个重要原因。即使是在GMS收集器中，枚举枚举根节点也要停顿。\n\n在HotSpot中使用OopMap的数据结构来保存对象的引用，从而在执行分析时不需要一个不漏的检查完所有的执行上下文和全局的引用位置，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。\n\n### 安全点\n\nHotSpot没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，就是安全点（SafePoint）。即程序执行时并非在所有的地方都要停顿下来开始GC，只有到达安全点才能暂停。\nSafePoint选定太少会让gc等待时间太长，太多会增加运行时的负荷。\n\n所以安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准进行选定的-因为每条指令执行时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行。“长时间执行”的最明显特征就是指令序列复用，例如方法调用，循环跳转，异常跳转等，所有具有这些功能的指令才会产生SafePoint。\n\n对于SafePoint，另一个需要考虑的问题是如何在GC发生时让所有线程都跑到最近的安全点上在停顿下来。有两个方案：\n\n- 抢先式中断\n\n不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。\n\n\n- 主动式中断\n\n当GC需要中断线程的时候，不直接对线程操作，仅设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真就自己中断挂起。轮询标志的地方和安全点是重合的，另外在加上创建对象需要分配内存的地方。\n\n\n\n### 安全区域\n\n安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。\n在线程执行到安全区域中的代码时，首先标识自己进入了安全区域，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了，在线程要离开安全区域，要检查是否已经完成了根节点枚举，如果完成了那现场就继续执行，否则必须等待直到收到可以离开安全区域的信号位置。\n\n\n## 垃圾收集器\n\n收集算法是内存回收的方法理论，垃圾收集器就是内存回收的具体实现。java虚拟机规范没有对垃圾收集器如何实现有规定，因此不同厂商、版本提供的垃圾收集器可能大不相同。\n\n> <font color='green'>Serial(/sɪəriəl/)收集器</font>\n\nSerial 收集器是最基本、历史最悠久的收集器。这个收集器是一个单线程的收集器，单线程的意义不仅仅说明它是只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到收集完成。\n\n![serial.png](./serial.png)\n\n目前为止，Serial依然是虚拟机运行在Client模式下的默认新生代收集器。\n优点：\n简单，高效。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集小路。\n\n> <font color='green'>ParNew收集器</font>\n\nparNew收集器其实就是Serial收集器的多线程版本，HotSpot第一款真正意义上的并发收集器\n\n![parnew.png](./parnew.png)\n\n参数：\n- -XX:+UseConcMarkSweepGC：选择后的默认新生代收集器\n- -XX:+UserParNewGC:强制指定\n- -XX:ParallelGCThreads：限制垃圾收集线程数\n\n> <font color='green'>Parallel Scavenge收集器</font>\n\n新生代收集器、使用复制算法、并行的多线程收集器。\n\n特点：\n关注点与其他收集器不同。CMS等收集器关注点是尽可能的缩短垃圾回收时用户线程停顿的时间，而Parallel Scavenge收集器目的则是达到一个可控制的吞吐量。吞吐量就是CPU运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行代码时间/(运行代码时间+垃圾收集时间)。\n\n停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合后台运算而不需要太多交互的任务。\n\n参数：\n\n- -XX:MaxGCPauseMillis:控制最大垃圾收集停顿时间\n\n参数值是一个大于0的毫米数，收集器尽可能保证内存回收花费的时间不超过设定值。不是说参数调至越小垃圾收集的时间越快，GC停顿时间压缩是以牺牲吞吐量和新生代空间来换取的。\n\n- -XX:GCTimeRatil:设置吞吐量大小\n参数值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量倒数，如果参数设置为19，那么预先的最大GC时间占总时间的5%（1/(1+19)）,默认为99，就是允许最大1%（1/(1+99)）的垃圾收集时间。\n\n- -XX:UseAdaptiveSizePolicy:这个一个开关参数，打开后，不需要手动指定新生代的大小、Eden和Survivor区的比例，晋升老年代对象年龄等细节参数，会动态调整这些参数以提供最适合的停顿时间或者最大的吞吐量。\n\n> <font color='green'>Serial Old 收集器</font>\n\nSerial Older 是 Serial 收集器的老年代版本，同样是一大单线程收集器，使用标记-整理算法。\n\n> <font color='green'>Parallel Old 收集器</font>\n\nParallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和标记-整理算法。\n\n> <font color='green'>CMS 收集器</font>\n\nCMS(Concurent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前java集中在互联网网站或者B/S系统服务端，比较重视服务响应时间，给用户带来比较好的体验，CMS非常服务符合这类需求。\n\nCMS采用标记-清除算法，整个步骤包括：\n\n- 初始标记（CMS initial mark）\n仅仅标记一下GC Roots能直接关联到的对象，速度很快。\n- 并发标记（CMS concurrent mark）\n进行GC Roots Tracing的过程\n- 重新标记（CMS remark）\n为了修正并发标记期间因用户程序继续运作而导致标志产生变动的那一部分对象的标记记录，这个阶段停顿时间一般会比初始化阶段稍长一些，但远比并发标记的时间短。\n- 并发清除（CMS concurrent sweep）\n\n初始标记和重新标记步骤任然需要“stop the world”。整个过程中耗时比较长的并发标记和并发清除过程是与用户线程一起工作的。\n\n![cms.png](./cms.png)\n\n**优点**\n并发收集，低停顿\n\n**缺点**\n- 对CPU资源非常敏感\n并发阶段，它不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐会降低。\n- 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC。\n- 产生大量空间碎片 \n\n\n> <font color=\"green\">G1收集器</font>\n\nG1是面向服务端的垃圾收集器。\n\n**特点**\n- 并行与并发\n充分利用多CPU多核环境下的硬件优势，缩短stop the world停顿时间。\n- 分代收集\n- 空间整合\nG1 从整体来看基于标记-整理算法实现，从局部看基于复制算法实现，运行期间不会产生内存碎片。\n- 可预测的停顿\n\n\n**步骤**\n\n- 初始标记\n- 并发标记\n- 最终标记\n- 筛选回收\n\n初始标记仅仅是标记下GC Roots能直接关联到的对象，并且修改TAMS（next top at mark start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程。\n并发标记是从GC Roots开始对堆中对象进行可达性分析，找到存活的对象，这段耗时长，但可与用户程序并发执行。\n最终标记是为了修正并发标记期间因用户程序继续运作而导致标记发生变化的那一部分标记记录。\n筛选回收首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。\n\n## 理解GC日志\n\n下面是一段GC日志：\n\n![GClog.png](./GClog.png)\n\n\"33.125：\" 和 \"100.67：\" 代表GC发生的时间，是从java虚拟机启动以来经过的描述。\n\n“[GC”和\"[Full GC\" 说明这次垃圾收集的停顿类型，而不是用来区分新生代还是老年代GC的。有 Full 说明这次GC是发生了“stop  the world”的。\n\n\"[DefNew\"、\"[Tenured\"、\"[Perm\"标识GC发生区域，这里显示的区域名和使用的GC收集器是密切相关的。如果使用Serial收集器中的新生代名称\"Default New Generation\"，显示\"[DefNew\"。如果使用ParNew,则为\"[Tenured\"，使用Parallel Scavenge收集器，那它配套的新生代名称为\"PSYoungGen\" 老年代和永久代同理，名称由收集器决定。\n\n\"3324K->152K(3712k)\"表示 GC前该内存区域已使用容量 -> GC 后该内存区域已使用容量（该内存区域总容量）。\n\n方括号之外的\"3324K->152K(11904)\" 表示 GC前java堆已使用容量->GC 后该java堆已使用容量（java堆总容量）。\n\"0.0025925 secs\"表示内存区域GC所占用的时间，单位秒。","source":"_posts/jvm/java-jvm-gc-algorithm-1.md","raw":"---\ntitle: 垃圾回收器算法的实现\ndate: 2019-05-27 15:49:28\ncategories: \n    - JAVA_JVM\ntags: \n    - JVM\n---\n\n## HOTSPOT算法实现\n### 枚举根节点\n\nGC Roots主要在全局性的引用（例如常量或者类静态属性）与执行上下文（例如栈帧中的本地变量表）中，java进行可达性分析时，对执行时间的敏感还体现在GC停顿上，因为分析工作必须在一个能确保一致性（分析过程中对象引用关系不能再不断变化）的快照中进行，这点是导致GC进行时必须停顿所有的java执行线程的一个重要原因。即使是在GMS收集器中，枚举枚举根节点也要停顿。\n\n在HotSpot中使用OopMap的数据结构来保存对象的引用，从而在执行分析时不需要一个不漏的检查完所有的执行上下文和全局的引用位置，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。\n\n### 安全点\n\nHotSpot没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，就是安全点（SafePoint）。即程序执行时并非在所有的地方都要停顿下来开始GC，只有到达安全点才能暂停。\nSafePoint选定太少会让gc等待时间太长，太多会增加运行时的负荷。\n\n所以安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准进行选定的-因为每条指令执行时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行。“长时间执行”的最明显特征就是指令序列复用，例如方法调用，循环跳转，异常跳转等，所有具有这些功能的指令才会产生SafePoint。\n\n对于SafePoint，另一个需要考虑的问题是如何在GC发生时让所有线程都跑到最近的安全点上在停顿下来。有两个方案：\n\n- 抢先式中断\n\n不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。\n\n\n- 主动式中断\n\n当GC需要中断线程的时候，不直接对线程操作，仅设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真就自己中断挂起。轮询标志的地方和安全点是重合的，另外在加上创建对象需要分配内存的地方。\n\n\n\n### 安全区域\n\n安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。\n在线程执行到安全区域中的代码时，首先标识自己进入了安全区域，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了，在线程要离开安全区域，要检查是否已经完成了根节点枚举，如果完成了那现场就继续执行，否则必须等待直到收到可以离开安全区域的信号位置。\n\n\n## 垃圾收集器\n\n收集算法是内存回收的方法理论，垃圾收集器就是内存回收的具体实现。java虚拟机规范没有对垃圾收集器如何实现有规定，因此不同厂商、版本提供的垃圾收集器可能大不相同。\n\n> <font color='green'>Serial(/sɪəriəl/)收集器</font>\n\nSerial 收集器是最基本、历史最悠久的收集器。这个收集器是一个单线程的收集器，单线程的意义不仅仅说明它是只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到收集完成。\n\n![serial.png](./serial.png)\n\n目前为止，Serial依然是虚拟机运行在Client模式下的默认新生代收集器。\n优点：\n简单，高效。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集小路。\n\n> <font color='green'>ParNew收集器</font>\n\nparNew收集器其实就是Serial收集器的多线程版本，HotSpot第一款真正意义上的并发收集器\n\n![parnew.png](./parnew.png)\n\n参数：\n- -XX:+UseConcMarkSweepGC：选择后的默认新生代收集器\n- -XX:+UserParNewGC:强制指定\n- -XX:ParallelGCThreads：限制垃圾收集线程数\n\n> <font color='green'>Parallel Scavenge收集器</font>\n\n新生代收集器、使用复制算法、并行的多线程收集器。\n\n特点：\n关注点与其他收集器不同。CMS等收集器关注点是尽可能的缩短垃圾回收时用户线程停顿的时间，而Parallel Scavenge收集器目的则是达到一个可控制的吞吐量。吞吐量就是CPU运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行代码时间/(运行代码时间+垃圾收集时间)。\n\n停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合后台运算而不需要太多交互的任务。\n\n参数：\n\n- -XX:MaxGCPauseMillis:控制最大垃圾收集停顿时间\n\n参数值是一个大于0的毫米数，收集器尽可能保证内存回收花费的时间不超过设定值。不是说参数调至越小垃圾收集的时间越快，GC停顿时间压缩是以牺牲吞吐量和新生代空间来换取的。\n\n- -XX:GCTimeRatil:设置吞吐量大小\n参数值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量倒数，如果参数设置为19，那么预先的最大GC时间占总时间的5%（1/(1+19)）,默认为99，就是允许最大1%（1/(1+99)）的垃圾收集时间。\n\n- -XX:UseAdaptiveSizePolicy:这个一个开关参数，打开后，不需要手动指定新生代的大小、Eden和Survivor区的比例，晋升老年代对象年龄等细节参数，会动态调整这些参数以提供最适合的停顿时间或者最大的吞吐量。\n\n> <font color='green'>Serial Old 收集器</font>\n\nSerial Older 是 Serial 收集器的老年代版本，同样是一大单线程收集器，使用标记-整理算法。\n\n> <font color='green'>Parallel Old 收集器</font>\n\nParallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和标记-整理算法。\n\n> <font color='green'>CMS 收集器</font>\n\nCMS(Concurent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前java集中在互联网网站或者B/S系统服务端，比较重视服务响应时间，给用户带来比较好的体验，CMS非常服务符合这类需求。\n\nCMS采用标记-清除算法，整个步骤包括：\n\n- 初始标记（CMS initial mark）\n仅仅标记一下GC Roots能直接关联到的对象，速度很快。\n- 并发标记（CMS concurrent mark）\n进行GC Roots Tracing的过程\n- 重新标记（CMS remark）\n为了修正并发标记期间因用户程序继续运作而导致标志产生变动的那一部分对象的标记记录，这个阶段停顿时间一般会比初始化阶段稍长一些，但远比并发标记的时间短。\n- 并发清除（CMS concurrent sweep）\n\n初始标记和重新标记步骤任然需要“stop the world”。整个过程中耗时比较长的并发标记和并发清除过程是与用户线程一起工作的。\n\n![cms.png](./cms.png)\n\n**优点**\n并发收集，低停顿\n\n**缺点**\n- 对CPU资源非常敏感\n并发阶段，它不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐会降低。\n- 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC。\n- 产生大量空间碎片 \n\n\n> <font color=\"green\">G1收集器</font>\n\nG1是面向服务端的垃圾收集器。\n\n**特点**\n- 并行与并发\n充分利用多CPU多核环境下的硬件优势，缩短stop the world停顿时间。\n- 分代收集\n- 空间整合\nG1 从整体来看基于标记-整理算法实现，从局部看基于复制算法实现，运行期间不会产生内存碎片。\n- 可预测的停顿\n\n\n**步骤**\n\n- 初始标记\n- 并发标记\n- 最终标记\n- 筛选回收\n\n初始标记仅仅是标记下GC Roots能直接关联到的对象，并且修改TAMS（next top at mark start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程。\n并发标记是从GC Roots开始对堆中对象进行可达性分析，找到存活的对象，这段耗时长，但可与用户程序并发执行。\n最终标记是为了修正并发标记期间因用户程序继续运作而导致标记发生变化的那一部分标记记录。\n筛选回收首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。\n\n## 理解GC日志\n\n下面是一段GC日志：\n\n![GClog.png](./GClog.png)\n\n\"33.125：\" 和 \"100.67：\" 代表GC发生的时间，是从java虚拟机启动以来经过的描述。\n\n“[GC”和\"[Full GC\" 说明这次垃圾收集的停顿类型，而不是用来区分新生代还是老年代GC的。有 Full 说明这次GC是发生了“stop  the world”的。\n\n\"[DefNew\"、\"[Tenured\"、\"[Perm\"标识GC发生区域，这里显示的区域名和使用的GC收集器是密切相关的。如果使用Serial收集器中的新生代名称\"Default New Generation\"，显示\"[DefNew\"。如果使用ParNew,则为\"[Tenured\"，使用Parallel Scavenge收集器，那它配套的新生代名称为\"PSYoungGen\" 老年代和永久代同理，名称由收集器决定。\n\n\"3324K->152K(3712k)\"表示 GC前该内存区域已使用容量 -> GC 后该内存区域已使用容量（该内存区域总容量）。\n\n方括号之外的\"3324K->152K(11904)\" 表示 GC前java堆已使用容量->GC 后该java堆已使用容量（java堆总容量）。\n\"0.0025925 secs\"表示内存区域GC所占用的时间，单位秒。","slug":"jvm/java-jvm-gc-algorithm-1","published":1,"updated":"2020-11-03T16:13:26.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y01000654vi4454255g","content":"<h2 id=\"HOTSPOT算法实现\"><a href=\"#HOTSPOT算法实现\" class=\"headerlink\" title=\"HOTSPOT算法实现\"></a>HOTSPOT算法实现</h2><h3 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h3><p>GC Roots主要在全局性的引用（例如常量或者类静态属性）与执行上下文（例如栈帧中的本地变量表）中，java进行可达性分析时，对执行时间的敏感还体现在GC停顿上，因为分析工作必须在一个能确保一致性（分析过程中对象引用关系不能再不断变化）的快照中进行，这点是导致GC进行时必须停顿所有的java执行线程的一个重要原因。即使是在GMS收集器中，枚举枚举根节点也要停顿。</p>\n<p>在HotSpot中使用OopMap的数据结构来保存对象的引用，从而在执行分析时不需要一个不漏的检查完所有的执行上下文和全局的引用位置，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>\n<h3 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h3><p>HotSpot没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，就是安全点（SafePoint）。即程序执行时并非在所有的地方都要停顿下来开始GC，只有到达安全点才能暂停。<br>SafePoint选定太少会让gc等待时间太长，太多会增加运行时的负荷。</p>\n<p>所以安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准进行选定的-因为每条指令执行时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行。“长时间执行”的最明显特征就是指令序列复用，例如方法调用，循环跳转，异常跳转等，所有具有这些功能的指令才会产生SafePoint。</p>\n<p>对于SafePoint，另一个需要考虑的问题是如何在GC发生时让所有线程都跑到最近的安全点上在停顿下来。有两个方案：</p>\n<ul>\n<li>抢先式中断</li>\n</ul>\n<p>不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。</p>\n<ul>\n<li>主动式中断</li>\n</ul>\n<p>当GC需要中断线程的时候，不直接对线程操作，仅设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真就自己中断挂起。轮询标志的地方和安全点是重合的，另外在加上创建对象需要分配内存的地方。</p>\n<h3 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h3><p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。<br>在线程执行到安全区域中的代码时，首先标识自己进入了安全区域，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了，在线程要离开安全区域，要检查是否已经完成了根节点枚举，如果完成了那现场就继续执行，否则必须等待直到收到可以离开安全区域的信号位置。</p>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><p>收集算法是内存回收的方法理论，垃圾收集器就是内存回收的具体实现。java虚拟机规范没有对垃圾收集器如何实现有规定，因此不同厂商、版本提供的垃圾收集器可能大不相同。</p>\n<blockquote>\n<p><font color='green'>Serial(/sɪəriəl/)收集器</font></p>\n</blockquote>\n<p>Serial 收集器是最基本、历史最悠久的收集器。这个收集器是一个单线程的收集器，单线程的意义不仅仅说明它是只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到收集完成。</p>\n<p><img src=\"./serial.png\" alt=\"serial.png\"></p>\n<p>目前为止，Serial依然是虚拟机运行在Client模式下的默认新生代收集器。<br>优点：<br>简单，高效。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集小路。</p>\n<blockquote>\n<p><font color='green'>ParNew收集器</font></p>\n</blockquote>\n<p>parNew收集器其实就是Serial收集器的多线程版本，HotSpot第一款真正意义上的并发收集器</p>\n<p><img src=\"./parnew.png\" alt=\"parnew.png\"></p>\n<p>参数：</p>\n<ul>\n<li>-XX:+UseConcMarkSweepGC：选择后的默认新生代收集器</li>\n<li>-XX:+UserParNewGC:强制指定</li>\n<li>-XX:ParallelGCThreads：限制垃圾收集线程数</li>\n</ul>\n<blockquote>\n<p><font color='green'>Parallel Scavenge收集器</font></p>\n</blockquote>\n<p>新生代收集器、使用复制算法、并行的多线程收集器。</p>\n<p>特点：<br>关注点与其他收集器不同。CMS等收集器关注点是尽可能的缩短垃圾回收时用户线程停顿的时间，而Parallel Scavenge收集器目的则是达到一个可控制的吞吐量。吞吐量就是CPU运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行代码时间/(运行代码时间+垃圾收集时间)。</p>\n<p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合后台运算而不需要太多交互的任务。</p>\n<p>参数：</p>\n<ul>\n<li>-XX:MaxGCPauseMillis:控制最大垃圾收集停顿时间</li>\n</ul>\n<p>参数值是一个大于0的毫米数，收集器尽可能保证内存回收花费的时间不超过设定值。不是说参数调至越小垃圾收集的时间越快，GC停顿时间压缩是以牺牲吞吐量和新生代空间来换取的。</p>\n<ul>\n<li><p>-XX:GCTimeRatil:设置吞吐量大小<br>参数值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量倒数，如果参数设置为19，那么预先的最大GC时间占总时间的5%（1/(1+19)）,默认为99，就是允许最大1%（1/(1+99)）的垃圾收集时间。</p>\n</li>\n<li><p>-XX:UseAdaptiveSizePolicy:这个一个开关参数，打开后，不需要手动指定新生代的大小、Eden和Survivor区的比例，晋升老年代对象年龄等细节参数，会动态调整这些参数以提供最适合的停顿时间或者最大的吞吐量。</p>\n</li>\n</ul>\n<blockquote>\n<p><font color='green'>Serial Old 收集器</font></p>\n</blockquote>\n<p>Serial Older 是 Serial 收集器的老年代版本，同样是一大单线程收集器，使用标记-整理算法。</p>\n<blockquote>\n<p><font color='green'>Parallel Old 收集器</font></p>\n</blockquote>\n<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和标记-整理算法。</p>\n<blockquote>\n<p><font color='green'>CMS 收集器</font></p>\n</blockquote>\n<p>CMS(Concurent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前java集中在互联网网站或者B/S系统服务端，比较重视服务响应时间，给用户带来比较好的体验，CMS非常服务符合这类需求。</p>\n<p>CMS采用标记-清除算法，整个步骤包括：</p>\n<ul>\n<li>初始标记（CMS initial mark）<br>仅仅标记一下GC Roots能直接关联到的对象，速度很快。</li>\n<li>并发标记（CMS concurrent mark）<br>进行GC Roots Tracing的过程</li>\n<li>重新标记（CMS remark）<br>为了修正并发标记期间因用户程序继续运作而导致标志产生变动的那一部分对象的标记记录，这个阶段停顿时间一般会比初始化阶段稍长一些，但远比并发标记的时间短。</li>\n<li>并发清除（CMS concurrent sweep）</li>\n</ul>\n<p>初始标记和重新标记步骤任然需要“stop the world”。整个过程中耗时比较长的并发标记和并发清除过程是与用户线程一起工作的。</p>\n<p><img src=\"./cms.png\" alt=\"cms.png\"></p>\n<p><strong>优点</strong><br>并发收集，低停顿</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>对CPU资源非常敏感<br>并发阶段，它不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐会降低。</li>\n<li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC。</li>\n<li>产生大量空间碎片 </li>\n</ul>\n<blockquote>\n<p><font color=\"green\">G1收集器</font></p>\n</blockquote>\n<p>G1是面向服务端的垃圾收集器。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li>并行与并发<br>充分利用多CPU多核环境下的硬件优势，缩短stop the world停顿时间。</li>\n<li>分代收集</li>\n<li>空间整合<br>G1 从整体来看基于标记-整理算法实现，从局部看基于复制算法实现，运行期间不会产生内存碎片。</li>\n<li>可预测的停顿</li>\n</ul>\n<p><strong>步骤</strong></p>\n<ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ul>\n<p>初始标记仅仅是标记下GC Roots能直接关联到的对象，并且修改TAMS（next top at mark start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程。<br>并发标记是从GC Roots开始对堆中对象进行可达性分析，找到存活的对象，这段耗时长，但可与用户程序并发执行。<br>最终标记是为了修正并发标记期间因用户程序继续运作而导致标记发生变化的那一部分标记记录。<br>筛选回收首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p>\n<h2 id=\"理解GC日志\"><a href=\"#理解GC日志\" class=\"headerlink\" title=\"理解GC日志\"></a>理解GC日志</h2><p>下面是一段GC日志：</p>\n<p><img src=\"./GClog.png\" alt=\"GClog.png\"></p>\n<p>“33.125：” 和 “100.67：” 代表GC发生的时间，是从java虚拟机启动以来经过的描述。</p>\n<p>“[GC”和”[Full GC” 说明这次垃圾收集的停顿类型，而不是用来区分新生代还是老年代GC的。有 Full 说明这次GC是发生了“stop  the world”的。</p>\n<p>“[DefNew”、”[Tenured”、”[Perm”标识GC发生区域，这里显示的区域名和使用的GC收集器是密切相关的。如果使用Serial收集器中的新生代名称”Default New Generation”，显示”[DefNew”。如果使用ParNew,则为”[Tenured”，使用Parallel Scavenge收集器，那它配套的新生代名称为”PSYoungGen” 老年代和永久代同理，名称由收集器决定。</p>\n<p>“3324K-&gt;152K(3712k)”表示 GC前该内存区域已使用容量 -&gt; GC 后该内存区域已使用容量（该内存区域总容量）。</p>\n<p>方括号之外的”3324K-&gt;152K(11904)” 表示 GC前java堆已使用容量-&gt;GC 后该java堆已使用容量（java堆总容量）。<br>“0.0025925 secs”表示内存区域GC所占用的时间，单位秒。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HOTSPOT算法实现\"><a href=\"#HOTSPOT算法实现\" class=\"headerlink\" title=\"HOTSPOT算法实现\"></a>HOTSPOT算法实现</h2><h3 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h3><p>GC Roots主要在全局性的引用（例如常量或者类静态属性）与执行上下文（例如栈帧中的本地变量表）中，java进行可达性分析时，对执行时间的敏感还体现在GC停顿上，因为分析工作必须在一个能确保一致性（分析过程中对象引用关系不能再不断变化）的快照中进行，这点是导致GC进行时必须停顿所有的java执行线程的一个重要原因。即使是在GMS收集器中，枚举枚举根节点也要停顿。</p>\n<p>在HotSpot中使用OopMap的数据结构来保存对象的引用，从而在执行分析时不需要一个不漏的检查完所有的执行上下文和全局的引用位置，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>\n<h3 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h3><p>HotSpot没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，就是安全点（SafePoint）。即程序执行时并非在所有的地方都要停顿下来开始GC，只有到达安全点才能暂停。<br>SafePoint选定太少会让gc等待时间太长，太多会增加运行时的负荷。</p>\n<p>所以安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准进行选定的-因为每条指令执行时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行。“长时间执行”的最明显特征就是指令序列复用，例如方法调用，循环跳转，异常跳转等，所有具有这些功能的指令才会产生SafePoint。</p>\n<p>对于SafePoint，另一个需要考虑的问题是如何在GC发生时让所有线程都跑到最近的安全点上在停顿下来。有两个方案：</p>\n<ul>\n<li>抢先式中断</li>\n</ul>\n<p>不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。</p>\n<ul>\n<li>主动式中断</li>\n</ul>\n<p>当GC需要中断线程的时候，不直接对线程操作，仅设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真就自己中断挂起。轮询标志的地方和安全点是重合的，另外在加上创建对象需要分配内存的地方。</p>\n<h3 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h3><p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。<br>在线程执行到安全区域中的代码时，首先标识自己进入了安全区域，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了，在线程要离开安全区域，要检查是否已经完成了根节点枚举，如果完成了那现场就继续执行，否则必须等待直到收到可以离开安全区域的信号位置。</p>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><p>收集算法是内存回收的方法理论，垃圾收集器就是内存回收的具体实现。java虚拟机规范没有对垃圾收集器如何实现有规定，因此不同厂商、版本提供的垃圾收集器可能大不相同。</p>\n<blockquote>\n<p><font color='green'>Serial(/sɪəriəl/)收集器</font></p>\n</blockquote>\n<p>Serial 收集器是最基本、历史最悠久的收集器。这个收集器是一个单线程的收集器，单线程的意义不仅仅说明它是只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到收集完成。</p>\n<p><img src=\"./serial.png\" alt=\"serial.png\"></p>\n<p>目前为止，Serial依然是虚拟机运行在Client模式下的默认新生代收集器。<br>优点：<br>简单，高效。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集小路。</p>\n<blockquote>\n<p><font color='green'>ParNew收集器</font></p>\n</blockquote>\n<p>parNew收集器其实就是Serial收集器的多线程版本，HotSpot第一款真正意义上的并发收集器</p>\n<p><img src=\"./parnew.png\" alt=\"parnew.png\"></p>\n<p>参数：</p>\n<ul>\n<li>-XX:+UseConcMarkSweepGC：选择后的默认新生代收集器</li>\n<li>-XX:+UserParNewGC:强制指定</li>\n<li>-XX:ParallelGCThreads：限制垃圾收集线程数</li>\n</ul>\n<blockquote>\n<p><font color='green'>Parallel Scavenge收集器</font></p>\n</blockquote>\n<p>新生代收集器、使用复制算法、并行的多线程收集器。</p>\n<p>特点：<br>关注点与其他收集器不同。CMS等收集器关注点是尽可能的缩短垃圾回收时用户线程停顿的时间，而Parallel Scavenge收集器目的则是达到一个可控制的吞吐量。吞吐量就是CPU运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行代码时间/(运行代码时间+垃圾收集时间)。</p>\n<p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合后台运算而不需要太多交互的任务。</p>\n<p>参数：</p>\n<ul>\n<li>-XX:MaxGCPauseMillis:控制最大垃圾收集停顿时间</li>\n</ul>\n<p>参数值是一个大于0的毫米数，收集器尽可能保证内存回收花费的时间不超过设定值。不是说参数调至越小垃圾收集的时间越快，GC停顿时间压缩是以牺牲吞吐量和新生代空间来换取的。</p>\n<ul>\n<li><p>-XX:GCTimeRatil:设置吞吐量大小<br>参数值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量倒数，如果参数设置为19，那么预先的最大GC时间占总时间的5%（1/(1+19)）,默认为99，就是允许最大1%（1/(1+99)）的垃圾收集时间。</p>\n</li>\n<li><p>-XX:UseAdaptiveSizePolicy:这个一个开关参数，打开后，不需要手动指定新生代的大小、Eden和Survivor区的比例，晋升老年代对象年龄等细节参数，会动态调整这些参数以提供最适合的停顿时间或者最大的吞吐量。</p>\n</li>\n</ul>\n<blockquote>\n<p><font color='green'>Serial Old 收集器</font></p>\n</blockquote>\n<p>Serial Older 是 Serial 收集器的老年代版本，同样是一大单线程收集器，使用标记-整理算法。</p>\n<blockquote>\n<p><font color='green'>Parallel Old 收集器</font></p>\n</blockquote>\n<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和标记-整理算法。</p>\n<blockquote>\n<p><font color='green'>CMS 收集器</font></p>\n</blockquote>\n<p>CMS(Concurent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前java集中在互联网网站或者B/S系统服务端，比较重视服务响应时间，给用户带来比较好的体验，CMS非常服务符合这类需求。</p>\n<p>CMS采用标记-清除算法，整个步骤包括：</p>\n<ul>\n<li>初始标记（CMS initial mark）<br>仅仅标记一下GC Roots能直接关联到的对象，速度很快。</li>\n<li>并发标记（CMS concurrent mark）<br>进行GC Roots Tracing的过程</li>\n<li>重新标记（CMS remark）<br>为了修正并发标记期间因用户程序继续运作而导致标志产生变动的那一部分对象的标记记录，这个阶段停顿时间一般会比初始化阶段稍长一些，但远比并发标记的时间短。</li>\n<li>并发清除（CMS concurrent sweep）</li>\n</ul>\n<p>初始标记和重新标记步骤任然需要“stop the world”。整个过程中耗时比较长的并发标记和并发清除过程是与用户线程一起工作的。</p>\n<p><img src=\"./cms.png\" alt=\"cms.png\"></p>\n<p><strong>优点</strong><br>并发收集，低停顿</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>对CPU资源非常敏感<br>并发阶段，它不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐会降低。</li>\n<li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC。</li>\n<li>产生大量空间碎片 </li>\n</ul>\n<blockquote>\n<p><font color=\"green\">G1收集器</font></p>\n</blockquote>\n<p>G1是面向服务端的垃圾收集器。</p>\n<p><strong>特点</strong></p>\n<ul>\n<li>并行与并发<br>充分利用多CPU多核环境下的硬件优势，缩短stop the world停顿时间。</li>\n<li>分代收集</li>\n<li>空间整合<br>G1 从整体来看基于标记-整理算法实现，从局部看基于复制算法实现，运行期间不会产生内存碎片。</li>\n<li>可预测的停顿</li>\n</ul>\n<p><strong>步骤</strong></p>\n<ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ul>\n<p>初始标记仅仅是标记下GC Roots能直接关联到的对象，并且修改TAMS（next top at mark start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程。<br>并发标记是从GC Roots开始对堆中对象进行可达性分析，找到存活的对象，这段耗时长，但可与用户程序并发执行。<br>最终标记是为了修正并发标记期间因用户程序继续运作而导致标记发生变化的那一部分标记记录。<br>筛选回收首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p>\n<h2 id=\"理解GC日志\"><a href=\"#理解GC日志\" class=\"headerlink\" title=\"理解GC日志\"></a>理解GC日志</h2><p>下面是一段GC日志：</p>\n<p><img src=\"./GClog.png\" alt=\"GClog.png\"></p>\n<p>“33.125：” 和 “100.67：” 代表GC发生的时间，是从java虚拟机启动以来经过的描述。</p>\n<p>“[GC”和”[Full GC” 说明这次垃圾收集的停顿类型，而不是用来区分新生代还是老年代GC的。有 Full 说明这次GC是发生了“stop  the world”的。</p>\n<p>“[DefNew”、”[Tenured”、”[Perm”标识GC发生区域，这里显示的区域名和使用的GC收集器是密切相关的。如果使用Serial收集器中的新生代名称”Default New Generation”，显示”[DefNew”。如果使用ParNew,则为”[Tenured”，使用Parallel Scavenge收集器，那它配套的新生代名称为”PSYoungGen” 老年代和永久代同理，名称由收集器决定。</p>\n<p>“3324K-&gt;152K(3712k)”表示 GC前该内存区域已使用容量 -&gt; GC 后该内存区域已使用容量（该内存区域总容量）。</p>\n<p>方括号之外的”3324K-&gt;152K(11904)” 表示 GC前java堆已使用容量-&gt;GC 后该java堆已使用容量（java堆总容量）。<br>“0.0025925 secs”表示内存区域GC所占用的时间，单位秒。</p>\n"},{"title":"垃圾收集算法","date":"2019-05-27T05:40:32.000Z","_content":"\n### 1.标记-清除算法\n\n标记-清除算法是最基础的收集算法。主要分为两步：标记，清除。首先标记处需要回收的对象，标记完成后统一回收被标记的对象。\n\n<font color='red'>缺点</font>\n- 效率问题：标记和清除效率都不高\n- 空间问题：标记清除后会产生大量不连续的内存碎片。如果程序在运行时需要分配较大的对象，无法找到足够大的内存就不能不提前触发另一次垃圾收集动作。\n\n![biaojiqingchu1.png](biaojiqingchu1.png)\n\n![biaojiqingchu2.png](biaojiqingchu2.png)\n\n### 2.复制算法\n\n复制算法可以更好的解决效率的问题。它将内存分为两块同等大小的区域。每次只回收其中一块区域。当垃圾回收器开始回收时，会将使用的一块内存中还存活的对象复制到另一块内存，然后一次清空这块使用的内存，每次都是对整个半区进行内存回收，内存分配不用考虑内存碎片的问题，只要一动堆顶的指针，按顺序分配内存即可，简单，高效。\n\n现在商业虚拟机都采用这种收集算法来回收新生代。通常将内存分为一块较大的Eden空间和两块比较小的Survivor空间，每次使用Eden和其中的一块Survivor，回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用到的Survivor空间。HotSpot默认Eden和Survivor比例是8:1，也就是每次新生代中可用空间为整个新生代容量的90%，只有10%的内存会被浪费。当Survivor空间不足时，需要依赖其他内存（老年代）进行分担担保。\n\n![fuzhi1.png](fuzhi1.png)\n\n![fuzhi2.png](fuzhi2.png)\n\n\n### 3.标记-整理算法\n\n标记-整理算法，标记的过程和标记-清除算法一下，后续步骤不是直接回收对象，而是让所有存活的对象都向一端一动，然后直接清除掉端边界以外的内存。\n\n![biaojizhengli.png](biaojizhengli.png)\n\n![biaojizhengli1.png](biaojizhengli1.png)\n\n### 4.分代收集算法\n\n当前商业虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块，java堆分为新生代和老年代，这样根据各个年代的特点采用适当的收集算法。新生代中每次都会有大量的对象死去，是有少量的存活，就选用复制算法。老年代中因为对象存活率高，没有额外的空间进行分配担保，就需要使用标记-清理或者标记整理算法进行回收。\n","source":"_posts/jvm/java-jvm-gc-algorithm.md","raw":"---\ntitle: 垃圾收集算法\ndate: 2019-05-27 13:40:32\ncategories: \n    - JAVA_JVM\ntags: \n    - JVM\n---\n\n### 1.标记-清除算法\n\n标记-清除算法是最基础的收集算法。主要分为两步：标记，清除。首先标记处需要回收的对象，标记完成后统一回收被标记的对象。\n\n<font color='red'>缺点</font>\n- 效率问题：标记和清除效率都不高\n- 空间问题：标记清除后会产生大量不连续的内存碎片。如果程序在运行时需要分配较大的对象，无法找到足够大的内存就不能不提前触发另一次垃圾收集动作。\n\n![biaojiqingchu1.png](biaojiqingchu1.png)\n\n![biaojiqingchu2.png](biaojiqingchu2.png)\n\n### 2.复制算法\n\n复制算法可以更好的解决效率的问题。它将内存分为两块同等大小的区域。每次只回收其中一块区域。当垃圾回收器开始回收时，会将使用的一块内存中还存活的对象复制到另一块内存，然后一次清空这块使用的内存，每次都是对整个半区进行内存回收，内存分配不用考虑内存碎片的问题，只要一动堆顶的指针，按顺序分配内存即可，简单，高效。\n\n现在商业虚拟机都采用这种收集算法来回收新生代。通常将内存分为一块较大的Eden空间和两块比较小的Survivor空间，每次使用Eden和其中的一块Survivor，回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用到的Survivor空间。HotSpot默认Eden和Survivor比例是8:1，也就是每次新生代中可用空间为整个新生代容量的90%，只有10%的内存会被浪费。当Survivor空间不足时，需要依赖其他内存（老年代）进行分担担保。\n\n![fuzhi1.png](fuzhi1.png)\n\n![fuzhi2.png](fuzhi2.png)\n\n\n### 3.标记-整理算法\n\n标记-整理算法，标记的过程和标记-清除算法一下，后续步骤不是直接回收对象，而是让所有存活的对象都向一端一动，然后直接清除掉端边界以外的内存。\n\n![biaojizhengli.png](biaojizhengli.png)\n\n![biaojizhengli1.png](biaojizhengli1.png)\n\n### 4.分代收集算法\n\n当前商业虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块，java堆分为新生代和老年代，这样根据各个年代的特点采用适当的收集算法。新生代中每次都会有大量的对象死去，是有少量的存活，就选用复制算法。老年代中因为对象存活率高，没有额外的空间进行分配担保，就需要使用标记-清理或者标记整理算法进行回收。\n","slug":"jvm/java-jvm-gc-algorithm","published":1,"updated":"2020-11-03T16:13:26.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y02000754vi0tts5emn","content":"<h3 id=\"1-标记-清除算法\"><a href=\"#1-标记-清除算法\" class=\"headerlink\" title=\"1.标记-清除算法\"></a>1.标记-清除算法</h3><p>标记-清除算法是最基础的收集算法。主要分为两步：标记，清除。首先标记处需要回收的对象，标记完成后统一回收被标记的对象。</p>\n<p><font color='red'>缺点</font></p>\n<ul>\n<li>效率问题：标记和清除效率都不高</li>\n<li>空间问题：标记清除后会产生大量不连续的内存碎片。如果程序在运行时需要分配较大的对象，无法找到足够大的内存就不能不提前触发另一次垃圾收集动作。</li>\n</ul>\n<p><img src=\"biaojiqingchu1.png\" alt=\"biaojiqingchu1.png\"></p>\n<p><img src=\"biaojiqingchu2.png\" alt=\"biaojiqingchu2.png\"></p>\n<h3 id=\"2-复制算法\"><a href=\"#2-复制算法\" class=\"headerlink\" title=\"2.复制算法\"></a>2.复制算法</h3><p>复制算法可以更好的解决效率的问题。它将内存分为两块同等大小的区域。每次只回收其中一块区域。当垃圾回收器开始回收时，会将使用的一块内存中还存活的对象复制到另一块内存，然后一次清空这块使用的内存，每次都是对整个半区进行内存回收，内存分配不用考虑内存碎片的问题，只要一动堆顶的指针，按顺序分配内存即可，简单，高效。</p>\n<p>现在商业虚拟机都采用这种收集算法来回收新生代。通常将内存分为一块较大的Eden空间和两块比较小的Survivor空间，每次使用Eden和其中的一块Survivor，回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用到的Survivor空间。HotSpot默认Eden和Survivor比例是8:1，也就是每次新生代中可用空间为整个新生代容量的90%，只有10%的内存会被浪费。当Survivor空间不足时，需要依赖其他内存（老年代）进行分担担保。</p>\n<p><img src=\"fuzhi1.png\" alt=\"fuzhi1.png\"></p>\n<p><img src=\"fuzhi2.png\" alt=\"fuzhi2.png\"></p>\n<h3 id=\"3-标记-整理算法\"><a href=\"#3-标记-整理算法\" class=\"headerlink\" title=\"3.标记-整理算法\"></a>3.标记-整理算法</h3><p>标记-整理算法，标记的过程和标记-清除算法一下，后续步骤不是直接回收对象，而是让所有存活的对象都向一端一动，然后直接清除掉端边界以外的内存。</p>\n<p><img src=\"biaojizhengli.png\" alt=\"biaojizhengli.png\"></p>\n<p><img src=\"biaojizhengli1.png\" alt=\"biaojizhengli1.png\"></p>\n<h3 id=\"4-分代收集算法\"><a href=\"#4-分代收集算法\" class=\"headerlink\" title=\"4.分代收集算法\"></a>4.分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块，java堆分为新生代和老年代，这样根据各个年代的特点采用适当的收集算法。新生代中每次都会有大量的对象死去，是有少量的存活，就选用复制算法。老年代中因为对象存活率高，没有额外的空间进行分配担保，就需要使用标记-清理或者标记整理算法进行回收。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-标记-清除算法\"><a href=\"#1-标记-清除算法\" class=\"headerlink\" title=\"1.标记-清除算法\"></a>1.标记-清除算法</h3><p>标记-清除算法是最基础的收集算法。主要分为两步：标记，清除。首先标记处需要回收的对象，标记完成后统一回收被标记的对象。</p>\n<p><font color='red'>缺点</font></p>\n<ul>\n<li>效率问题：标记和清除效率都不高</li>\n<li>空间问题：标记清除后会产生大量不连续的内存碎片。如果程序在运行时需要分配较大的对象，无法找到足够大的内存就不能不提前触发另一次垃圾收集动作。</li>\n</ul>\n<p><img src=\"biaojiqingchu1.png\" alt=\"biaojiqingchu1.png\"></p>\n<p><img src=\"biaojiqingchu2.png\" alt=\"biaojiqingchu2.png\"></p>\n<h3 id=\"2-复制算法\"><a href=\"#2-复制算法\" class=\"headerlink\" title=\"2.复制算法\"></a>2.复制算法</h3><p>复制算法可以更好的解决效率的问题。它将内存分为两块同等大小的区域。每次只回收其中一块区域。当垃圾回收器开始回收时，会将使用的一块内存中还存活的对象复制到另一块内存，然后一次清空这块使用的内存，每次都是对整个半区进行内存回收，内存分配不用考虑内存碎片的问题，只要一动堆顶的指针，按顺序分配内存即可，简单，高效。</p>\n<p>现在商业虚拟机都采用这种收集算法来回收新生代。通常将内存分为一块较大的Eden空间和两块比较小的Survivor空间，每次使用Eden和其中的一块Survivor，回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用到的Survivor空间。HotSpot默认Eden和Survivor比例是8:1，也就是每次新生代中可用空间为整个新生代容量的90%，只有10%的内存会被浪费。当Survivor空间不足时，需要依赖其他内存（老年代）进行分担担保。</p>\n<p><img src=\"fuzhi1.png\" alt=\"fuzhi1.png\"></p>\n<p><img src=\"fuzhi2.png\" alt=\"fuzhi2.png\"></p>\n<h3 id=\"3-标记-整理算法\"><a href=\"#3-标记-整理算法\" class=\"headerlink\" title=\"3.标记-整理算法\"></a>3.标记-整理算法</h3><p>标记-整理算法，标记的过程和标记-清除算法一下，后续步骤不是直接回收对象，而是让所有存活的对象都向一端一动，然后直接清除掉端边界以外的内存。</p>\n<p><img src=\"biaojizhengli.png\" alt=\"biaojizhengli.png\"></p>\n<p><img src=\"biaojizhengli1.png\" alt=\"biaojizhengli1.png\"></p>\n<h3 id=\"4-分代收集算法\"><a href=\"#4-分代收集算法\" class=\"headerlink\" title=\"4.分代收集算法\"></a>4.分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块，java堆分为新生代和老年代，这样根据各个年代的特点采用适当的收集算法。新生代中每次都会有大量的对象死去，是有少量的存活，就选用复制算法。老年代中因为对象存活率高，没有额外的空间进行分配担保，就需要使用标记-清理或者标记整理算法进行回收。</p>\n"},{"title":"JVM学习笔记-java对象","date":"2019-05-22T07:47:30.000Z","_content":"&nbsp; &nbsp; &nbsp; &nbsp;我们在学习了java虚拟机的内存知识后，我们接下来研究下对象的在java堆中分配、布局和访问的全过程。\n\n\n###  <font color=#008000>对象的创建</font>\n\n&nbsp; &nbsp; &nbsp; &nbsp;在我们开发的过程中，用到的最多的当然还是通过 new 关键字去创建一个对象，那么在创建是一个怎样的过程呢？\n\n&nbsp; &nbsp; &nbsp; &nbsp;1.在执行 new 指令时，会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引入代表的类是否已被加载、解析和初始化。如果没有就需要就行响应的类加载过程。（加载过程后面会说）\n\n&nbsp; &nbsp; &nbsp; &nbsp;2.在类加载检查通过后，会为新生的对象分配内存空间，对象所需要的内存空间，在类加载完成后便可完全确定下来，为对象分配空间等同于在java堆中划分出一块内存。分配内存空间有两种分配方式：\n\n- 指针碰撞\n\n&nbsp; &nbsp; &nbsp; &nbsp;java堆的内存空间是**规整**的，使用的内存空间放在一起，空闲的内存空间放在一起，中间使用一个指针作为分界点的指示器。所分配的内存就是仅仅把指针箱空闲的那边挪动一段与对象大小相等的距离。\n\n- 空闲列表\n\n&nbsp; &nbsp; &nbsp; &nbsp;java堆内存空间不是**规整**的，使用的和没有使用的交错在一起，虚拟机会维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一个块足够大的空间划分给对象实例，并更新列表上的记录。\n\n&nbsp; &nbsp; &nbsp; &nbsp; 具体使用哪种方式取决于java堆是否是规整的，而是否规整取决于垃圾收集器是否带有压缩整理功能决定。所以在使用Serial、ParNew等带有Compact过程的收集器，系统使用分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的采用空闲列表。\n&nbsp; &nbsp; &nbsp; &nbsp;在划分空间的时候，如果频繁的创建对象，就会出现线程安全问题。比如两个线程A和B，虚拟机在为A分配内存的时候，指针还没有来得及修改，对象B同时使用了原来的指针来分配内存。决定方法有两种，\n一种是使用CAS配上失败重试的方式保证更新操作的原子性。\n另一种是按照线程的维度去分配空间。每个线程会预先分配到一小块的内存，称为<font color=\"red\">本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</font>。需要分配内存的时候，在该线程的TLAB上去分配，只有TLAB用完了，并分配新的TLAB才需要同步锁定。通过-XX:+/-UseTLAB参数设置是否使用TLAB。\n\n&nbsp; &nbsp; &nbsp; &nbsp;3.分配内存后，虚拟机需要将分配的内存空间都初始化为零值。从而保证对象的实例字段在java代码中可以不赋初始值就可以直接使用。\n\n&nbsp; &nbsp; &nbsp; &nbsp;4.接下来要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象头中。\n\n&nbsp; &nbsp; &nbsp; &nbsp;5.完成上述工作，需要执行 init 方法，把对象按照程序员的意愿进行初始化。这样一个真正的对象才算完全生产出来。\n\n\n###  <font color=#008000>对象的内存布局</font>\n\n&nbsp; &nbsp; &nbsp; &nbsp;对象的存储布局分为三个区域：对象头（Header）、实例数据（Instant Data）和对其填充（Padding）\n\n#### 对象头\n\n&nbsp; &nbsp; &nbsp; &nbsp;第一部分用于存储对象自身运行时数据，哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，官方称为“Mark Word”。这部分数据的长度在32位和64位的虚拟机上分别是32bit 和 64bit。Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储更多的信息。他会根据对象的状态复用自己的存储空间。比如，在32位的HotSpot虚拟机上，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中，25bit用于存储对象的哈希码，4bit用于存储对象的分代年龄，2bit存储锁标志位，1bit固定为0。而其他状态下的存储如下。\n\n存储内容|标志位|状态\n:-:|:-:|:-:\n对象哈希码、对象分代年龄|01|未锁定\n指向锁记录的指针|00|轻量级锁\n执行重量级锁的指针|10|膨胀（重量级锁定）\n空，不需要记录信息|11|GC标志\n偏向线程ID、偏向时间戳、对象分代年龄|01|可偏向\n\n&nbsp; &nbsp; &nbsp; &nbsp; 另一部分是类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。但是不是所有的虚拟机都需要在对象数据上保留类型指针，也就是说查找对象的元数据信息并不是一定需要经过对象本身。如果对象是一个java数组，那对象头还需要一块用于记录数据长度的数据，因为虚拟机可以通过普通的java对象的元数据信息确定java对象的大小，但是从数据的元数据中无法确定数组的大小。\n\n### 实例数据\n\n&nbsp; &nbsp; &nbsp; &nbsp; 对象真正存储的有效信息。也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。\n\n### 对其填充\n\n&nbsp; &nbsp; &nbsp; &nbsp; 不是必然存在额，也没有特殊的意义，仅仅起着占位符的作用。HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍。换句话，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。\n\n\n###  <font color=#008000>对象的访问定位</font>\n\n&nbsp; &nbsp; &nbsp; &nbsp;java程序通过栈上的reference数据来操作堆上的具体对象。reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义通过何种方式去定位、访问堆中对象的具体位置，所以对象访问方式取决于虚拟机事项而定。目前访问方式主要有两种：\n\n- 使用句柄\n\njava堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。\n\n使用句柄最大的好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。\n![句柄池](./jubinchi.png)\n\n\n\n- 直接指针\n\njava堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。\n\n使用直接指针速度更快，由于对象访问在java中非常频繁，这类开销积少成多，也是一项非常可观的执行成本。HotSpot就是使用直接指针。\n\n![直接指针](./zhijiezhizhen.png)\n\n\n","source":"_posts/jvm/java-jvm-object.md","raw":"---\ntitle: JVM学习笔记-java对象\ndate: 2019-05-22 15:47:30\ncategories: \n    - JAVA_JVM\ntags: \n    - JVM\n---\n&nbsp; &nbsp; &nbsp; &nbsp;我们在学习了java虚拟机的内存知识后，我们接下来研究下对象的在java堆中分配、布局和访问的全过程。\n\n\n###  <font color=#008000>对象的创建</font>\n\n&nbsp; &nbsp; &nbsp; &nbsp;在我们开发的过程中，用到的最多的当然还是通过 new 关键字去创建一个对象，那么在创建是一个怎样的过程呢？\n\n&nbsp; &nbsp; &nbsp; &nbsp;1.在执行 new 指令时，会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引入代表的类是否已被加载、解析和初始化。如果没有就需要就行响应的类加载过程。（加载过程后面会说）\n\n&nbsp; &nbsp; &nbsp; &nbsp;2.在类加载检查通过后，会为新生的对象分配内存空间，对象所需要的内存空间，在类加载完成后便可完全确定下来，为对象分配空间等同于在java堆中划分出一块内存。分配内存空间有两种分配方式：\n\n- 指针碰撞\n\n&nbsp; &nbsp; &nbsp; &nbsp;java堆的内存空间是**规整**的，使用的内存空间放在一起，空闲的内存空间放在一起，中间使用一个指针作为分界点的指示器。所分配的内存就是仅仅把指针箱空闲的那边挪动一段与对象大小相等的距离。\n\n- 空闲列表\n\n&nbsp; &nbsp; &nbsp; &nbsp;java堆内存空间不是**规整**的，使用的和没有使用的交错在一起，虚拟机会维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一个块足够大的空间划分给对象实例，并更新列表上的记录。\n\n&nbsp; &nbsp; &nbsp; &nbsp; 具体使用哪种方式取决于java堆是否是规整的，而是否规整取决于垃圾收集器是否带有压缩整理功能决定。所以在使用Serial、ParNew等带有Compact过程的收集器，系统使用分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的采用空闲列表。\n&nbsp; &nbsp; &nbsp; &nbsp;在划分空间的时候，如果频繁的创建对象，就会出现线程安全问题。比如两个线程A和B，虚拟机在为A分配内存的时候，指针还没有来得及修改，对象B同时使用了原来的指针来分配内存。决定方法有两种，\n一种是使用CAS配上失败重试的方式保证更新操作的原子性。\n另一种是按照线程的维度去分配空间。每个线程会预先分配到一小块的内存，称为<font color=\"red\">本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</font>。需要分配内存的时候，在该线程的TLAB上去分配，只有TLAB用完了，并分配新的TLAB才需要同步锁定。通过-XX:+/-UseTLAB参数设置是否使用TLAB。\n\n&nbsp; &nbsp; &nbsp; &nbsp;3.分配内存后，虚拟机需要将分配的内存空间都初始化为零值。从而保证对象的实例字段在java代码中可以不赋初始值就可以直接使用。\n\n&nbsp; &nbsp; &nbsp; &nbsp;4.接下来要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象头中。\n\n&nbsp; &nbsp; &nbsp; &nbsp;5.完成上述工作，需要执行 init 方法，把对象按照程序员的意愿进行初始化。这样一个真正的对象才算完全生产出来。\n\n\n###  <font color=#008000>对象的内存布局</font>\n\n&nbsp; &nbsp; &nbsp; &nbsp;对象的存储布局分为三个区域：对象头（Header）、实例数据（Instant Data）和对其填充（Padding）\n\n#### 对象头\n\n&nbsp; &nbsp; &nbsp; &nbsp;第一部分用于存储对象自身运行时数据，哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，官方称为“Mark Word”。这部分数据的长度在32位和64位的虚拟机上分别是32bit 和 64bit。Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储更多的信息。他会根据对象的状态复用自己的存储空间。比如，在32位的HotSpot虚拟机上，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中，25bit用于存储对象的哈希码，4bit用于存储对象的分代年龄，2bit存储锁标志位，1bit固定为0。而其他状态下的存储如下。\n\n存储内容|标志位|状态\n:-:|:-:|:-:\n对象哈希码、对象分代年龄|01|未锁定\n指向锁记录的指针|00|轻量级锁\n执行重量级锁的指针|10|膨胀（重量级锁定）\n空，不需要记录信息|11|GC标志\n偏向线程ID、偏向时间戳、对象分代年龄|01|可偏向\n\n&nbsp; &nbsp; &nbsp; &nbsp; 另一部分是类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。但是不是所有的虚拟机都需要在对象数据上保留类型指针，也就是说查找对象的元数据信息并不是一定需要经过对象本身。如果对象是一个java数组，那对象头还需要一块用于记录数据长度的数据，因为虚拟机可以通过普通的java对象的元数据信息确定java对象的大小，但是从数据的元数据中无法确定数组的大小。\n\n### 实例数据\n\n&nbsp; &nbsp; &nbsp; &nbsp; 对象真正存储的有效信息。也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。\n\n### 对其填充\n\n&nbsp; &nbsp; &nbsp; &nbsp; 不是必然存在额，也没有特殊的意义，仅仅起着占位符的作用。HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍。换句话，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。\n\n\n###  <font color=#008000>对象的访问定位</font>\n\n&nbsp; &nbsp; &nbsp; &nbsp;java程序通过栈上的reference数据来操作堆上的具体对象。reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义通过何种方式去定位、访问堆中对象的具体位置，所以对象访问方式取决于虚拟机事项而定。目前访问方式主要有两种：\n\n- 使用句柄\n\njava堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。\n\n使用句柄最大的好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。\n![句柄池](./jubinchi.png)\n\n\n\n- 直接指针\n\njava堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。\n\n使用直接指针速度更快，由于对象访问在java中非常频繁，这类开销积少成多，也是一项非常可观的执行成本。HotSpot就是使用直接指针。\n\n![直接指针](./zhijiezhizhen.png)\n\n\n","slug":"jvm/java-jvm-object","published":1,"updated":"2020-11-03T16:13:26.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y03000854vi33l8h23e","content":"<p>&nbsp; &nbsp; &nbsp; &nbsp;我们在学习了java虚拟机的内存知识后，我们接下来研究下对象的在java堆中分配、布局和访问的全过程。</p>\n<h3 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a><font color=#008000>对象的创建</font></h3><p>&nbsp; &nbsp; &nbsp; &nbsp;在我们开发的过程中，用到的最多的当然还是通过 new 关键字去创建一个对象，那么在创建是一个怎样的过程呢？</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;1.在执行 new 指令时，会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引入代表的类是否已被加载、解析和初始化。如果没有就需要就行响应的类加载过程。（加载过程后面会说）</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;2.在类加载检查通过后，会为新生的对象分配内存空间，对象所需要的内存空间，在类加载完成后便可完全确定下来，为对象分配空间等同于在java堆中划分出一块内存。分配内存空间有两种分配方式：</p>\n<ul>\n<li>指针碰撞</li>\n</ul>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;java堆的内存空间是<strong>规整</strong>的，使用的内存空间放在一起，空闲的内存空间放在一起，中间使用一个指针作为分界点的指示器。所分配的内存就是仅仅把指针箱空闲的那边挪动一段与对象大小相等的距离。</p>\n<ul>\n<li>空闲列表</li>\n</ul>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;java堆内存空间不是<strong>规整</strong>的，使用的和没有使用的交错在一起，虚拟机会维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一个块足够大的空间划分给对象实例，并更新列表上的记录。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 具体使用哪种方式取决于java堆是否是规整的，而是否规整取决于垃圾收集器是否带有压缩整理功能决定。所以在使用Serial、ParNew等带有Compact过程的收集器，系统使用分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的采用空闲列表。<br>&nbsp; &nbsp; &nbsp; &nbsp;在划分空间的时候，如果频繁的创建对象，就会出现线程安全问题。比如两个线程A和B，虚拟机在为A分配内存的时候，指针还没有来得及修改，对象B同时使用了原来的指针来分配内存。决定方法有两种，<br>一种是使用CAS配上失败重试的方式保证更新操作的原子性。<br>另一种是按照线程的维度去分配空间。每个线程会预先分配到一小块的内存，称为<font color=\"red\">本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</font>。需要分配内存的时候，在该线程的TLAB上去分配，只有TLAB用完了，并分配新的TLAB才需要同步锁定。通过-XX:+/-UseTLAB参数设置是否使用TLAB。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;3.分配内存后，虚拟机需要将分配的内存空间都初始化为零值。从而保证对象的实例字段在java代码中可以不赋初始值就可以直接使用。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;4.接下来要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象头中。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;5.完成上述工作，需要执行 init 方法，把对象按照程序员的意愿进行初始化。这样一个真正的对象才算完全生产出来。</p>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a><font color=#008000>对象的内存布局</font></h3><p>&nbsp; &nbsp; &nbsp; &nbsp;对象的存储布局分为三个区域：对象头（Header）、实例数据（Instant Data）和对其填充（Padding）</p>\n<h4 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;第一部分用于存储对象自身运行时数据，哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，官方称为“Mark Word”。这部分数据的长度在32位和64位的虚拟机上分别是32bit 和 64bit。Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储更多的信息。他会根据对象的状态复用自己的存储空间。比如，在32位的HotSpot虚拟机上，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中，25bit用于存储对象的哈希码，4bit用于存储对象的分代年龄，2bit存储锁标志位，1bit固定为0。而其他状态下的存储如下。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">存储内容</th>\n<th align=\"center\">标志位</th>\n<th align=\"center\">状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">对象哈希码、对象分代年龄</td>\n<td align=\"center\">01</td>\n<td align=\"center\">未锁定</td>\n</tr>\n<tr>\n<td align=\"center\">指向锁记录的指针</td>\n<td align=\"center\">00</td>\n<td align=\"center\">轻量级锁</td>\n</tr>\n<tr>\n<td align=\"center\">执行重量级锁的指针</td>\n<td align=\"center\">10</td>\n<td align=\"center\">膨胀（重量级锁定）</td>\n</tr>\n<tr>\n<td align=\"center\">空，不需要记录信息</td>\n<td align=\"center\">11</td>\n<td align=\"center\">GC标志</td>\n</tr>\n<tr>\n<td align=\"center\">偏向线程ID、偏向时间戳、对象分代年龄</td>\n<td align=\"center\">01</td>\n<td align=\"center\">可偏向</td>\n</tr>\n</tbody></table>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 另一部分是类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。但是不是所有的虚拟机都需要在对象数据上保留类型指针，也就是说查找对象的元数据信息并不是一定需要经过对象本身。如果对象是一个java数组，那对象头还需要一块用于记录数据长度的数据，因为虚拟机可以通过普通的java对象的元数据信息确定java对象的大小，但是从数据的元数据中无法确定数组的大小。</p>\n<h3 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 对象真正存储的有效信息。也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p>\n<h3 id=\"对其填充\"><a href=\"#对其填充\" class=\"headerlink\" title=\"对其填充\"></a>对其填充</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 不是必然存在额，也没有特殊的意义，仅仅起着占位符的作用。HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍。换句话，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。</p>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a><font color=#008000>对象的访问定位</font></h3><p>&nbsp; &nbsp; &nbsp; &nbsp;java程序通过栈上的reference数据来操作堆上的具体对象。reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义通过何种方式去定位、访问堆中对象的具体位置，所以对象访问方式取决于虚拟机事项而定。目前访问方式主要有两种：</p>\n<ul>\n<li>使用句柄</li>\n</ul>\n<p>java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。</p>\n<p>使用句柄最大的好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br><img src=\"./jubinchi.png\" alt=\"句柄池\"></p>\n<ul>\n<li>直接指针</li>\n</ul>\n<p>java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p>\n<p>使用直接指针速度更快，由于对象访问在java中非常频繁，这类开销积少成多，也是一项非常可观的执行成本。HotSpot就是使用直接指针。</p>\n<p><img src=\"./zhijiezhizhen.png\" alt=\"直接指针\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>&nbsp; &nbsp; &nbsp; &nbsp;我们在学习了java虚拟机的内存知识后，我们接下来研究下对象的在java堆中分配、布局和访问的全过程。</p>\n<h3 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a><font color=#008000>对象的创建</font></h3><p>&nbsp; &nbsp; &nbsp; &nbsp;在我们开发的过程中，用到的最多的当然还是通过 new 关键字去创建一个对象，那么在创建是一个怎样的过程呢？</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;1.在执行 new 指令时，会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引入代表的类是否已被加载、解析和初始化。如果没有就需要就行响应的类加载过程。（加载过程后面会说）</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;2.在类加载检查通过后，会为新生的对象分配内存空间，对象所需要的内存空间，在类加载完成后便可完全确定下来，为对象分配空间等同于在java堆中划分出一块内存。分配内存空间有两种分配方式：</p>\n<ul>\n<li>指针碰撞</li>\n</ul>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;java堆的内存空间是<strong>规整</strong>的，使用的内存空间放在一起，空闲的内存空间放在一起，中间使用一个指针作为分界点的指示器。所分配的内存就是仅仅把指针箱空闲的那边挪动一段与对象大小相等的距离。</p>\n<ul>\n<li>空闲列表</li>\n</ul>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;java堆内存空间不是<strong>规整</strong>的，使用的和没有使用的交错在一起，虚拟机会维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一个块足够大的空间划分给对象实例，并更新列表上的记录。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 具体使用哪种方式取决于java堆是否是规整的，而是否规整取决于垃圾收集器是否带有压缩整理功能决定。所以在使用Serial、ParNew等带有Compact过程的收集器，系统使用分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的采用空闲列表。<br>&nbsp; &nbsp; &nbsp; &nbsp;在划分空间的时候，如果频繁的创建对象，就会出现线程安全问题。比如两个线程A和B，虚拟机在为A分配内存的时候，指针还没有来得及修改，对象B同时使用了原来的指针来分配内存。决定方法有两种，<br>一种是使用CAS配上失败重试的方式保证更新操作的原子性。<br>另一种是按照线程的维度去分配空间。每个线程会预先分配到一小块的内存，称为<font color=\"red\">本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</font>。需要分配内存的时候，在该线程的TLAB上去分配，只有TLAB用完了，并分配新的TLAB才需要同步锁定。通过-XX:+/-UseTLAB参数设置是否使用TLAB。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;3.分配内存后，虚拟机需要将分配的内存空间都初始化为零值。从而保证对象的实例字段在java代码中可以不赋初始值就可以直接使用。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;4.接下来要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象头中。</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;5.完成上述工作，需要执行 init 方法，把对象按照程序员的意愿进行初始化。这样一个真正的对象才算完全生产出来。</p>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a><font color=#008000>对象的内存布局</font></h3><p>&nbsp; &nbsp; &nbsp; &nbsp;对象的存储布局分为三个区域：对象头（Header）、实例数据（Instant Data）和对其填充（Padding）</p>\n<h4 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;第一部分用于存储对象自身运行时数据，哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，官方称为“Mark Word”。这部分数据的长度在32位和64位的虚拟机上分别是32bit 和 64bit。Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储更多的信息。他会根据对象的状态复用自己的存储空间。比如，在32位的HotSpot虚拟机上，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中，25bit用于存储对象的哈希码，4bit用于存储对象的分代年龄，2bit存储锁标志位，1bit固定为0。而其他状态下的存储如下。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">存储内容</th>\n<th align=\"center\">标志位</th>\n<th align=\"center\">状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">对象哈希码、对象分代年龄</td>\n<td align=\"center\">01</td>\n<td align=\"center\">未锁定</td>\n</tr>\n<tr>\n<td align=\"center\">指向锁记录的指针</td>\n<td align=\"center\">00</td>\n<td align=\"center\">轻量级锁</td>\n</tr>\n<tr>\n<td align=\"center\">执行重量级锁的指针</td>\n<td align=\"center\">10</td>\n<td align=\"center\">膨胀（重量级锁定）</td>\n</tr>\n<tr>\n<td align=\"center\">空，不需要记录信息</td>\n<td align=\"center\">11</td>\n<td align=\"center\">GC标志</td>\n</tr>\n<tr>\n<td align=\"center\">偏向线程ID、偏向时间戳、对象分代年龄</td>\n<td align=\"center\">01</td>\n<td align=\"center\">可偏向</td>\n</tr>\n</tbody></table>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; 另一部分是类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。但是不是所有的虚拟机都需要在对象数据上保留类型指针，也就是说查找对象的元数据信息并不是一定需要经过对象本身。如果对象是一个java数组，那对象头还需要一块用于记录数据长度的数据，因为虚拟机可以通过普通的java对象的元数据信息确定java对象的大小，但是从数据的元数据中无法确定数组的大小。</p>\n<h3 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 对象真正存储的有效信息。也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p>\n<h3 id=\"对其填充\"><a href=\"#对其填充\" class=\"headerlink\" title=\"对其填充\"></a>对其填充</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; 不是必然存在额，也没有特殊的意义，仅仅起着占位符的作用。HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍。换句话，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。</p>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a><font color=#008000>对象的访问定位</font></h3><p>&nbsp; &nbsp; &nbsp; &nbsp;java程序通过栈上的reference数据来操作堆上的具体对象。reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义通过何种方式去定位、访问堆中对象的具体位置，所以对象访问方式取决于虚拟机事项而定。目前访问方式主要有两种：</p>\n<ul>\n<li>使用句柄</li>\n</ul>\n<p>java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。</p>\n<p>使用句柄最大的好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br><img src=\"./jubinchi.png\" alt=\"句柄池\"></p>\n<ul>\n<li>直接指针</li>\n</ul>\n<p>java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p>\n<p>使用直接指针速度更快，由于对象访问在java中非常频繁，这类开销积少成多，也是一项非常可观的执行成本。HotSpot就是使用直接指针。</p>\n<p><img src=\"./zhijiezhizhen.png\" alt=\"直接指针\"></p>\n"},{"title":"java-jvm-命令的使用","date":"2020-11-26T03:23:33.000Z","_content":"\n# jps\n\njps是JavaVirtual Machine Process Status Tool的缩写，是java提供的查看进程的命令\n\n```\n命令格式：jps [options ] [ hostid ] \n\n[options]选项 ：\n-q：仅输出VM标识符，不包括classname,jar name,arguments in main method \n-m：输出main method的参数 \n-l：输出完全的包名，应用主类名，jar的完全路径名 \n-v：输出jvm参数 \n-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 \n-Joption：传递参数到vm,例如:-J-Xms512m\n\n[hostid]：\n[protocol:][[//]hostname][:port][/servername]\n命令的输出格式 ：\nlvmid [ [ classname| JARfilename | \"Unknown\"] [ arg* ] [ jvmarg* ] ]\n\n```\n\n## 1. jps\n\n{% asset_img jps1.png [jps1.png] %}\n\n## 2. jps -q :仅仅显示java进程号\n\n{% asset_img jps2.png [jps2.png] %}\n\n## 3. jps -l :输出主类或者jar的完全路径名\n\n{% asset_img jps3.png [jps3.png] %}\n\n\n# jstat\n\njstat -gc PID :查看java进程的内存和GC情况\n\n{% asset_img stat1.png [stat1.png]%}\n\njstat -gccapacity PID 堆内存分析\n\njstat -gcnew PID 年轻代GC分析\n\njstat -gcnewcapacity PID 年轻代内存分析\n\njstat -gcold PID 老年代GC分析\n\njstat -gcoldcapacity PID 老年代内存分析\n\njstat -gcmetacapacity PID 元数据内存分析\n\n\n\n","source":"_posts/jvm/java-jvm-命令的使用.md","raw":"---\ntitle: java-jvm-命令的使用\ndate: 2020-11-26 11:23:33\ncategories: \n    - JAVA_JVM\ntags: \n    - JVM\n---\n\n# jps\n\njps是JavaVirtual Machine Process Status Tool的缩写，是java提供的查看进程的命令\n\n```\n命令格式：jps [options ] [ hostid ] \n\n[options]选项 ：\n-q：仅输出VM标识符，不包括classname,jar name,arguments in main method \n-m：输出main method的参数 \n-l：输出完全的包名，应用主类名，jar的完全路径名 \n-v：输出jvm参数 \n-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 \n-Joption：传递参数到vm,例如:-J-Xms512m\n\n[hostid]：\n[protocol:][[//]hostname][:port][/servername]\n命令的输出格式 ：\nlvmid [ [ classname| JARfilename | \"Unknown\"] [ arg* ] [ jvmarg* ] ]\n\n```\n\n## 1. jps\n\n{% asset_img jps1.png [jps1.png] %}\n\n## 2. jps -q :仅仅显示java进程号\n\n{% asset_img jps2.png [jps2.png] %}\n\n## 3. jps -l :输出主类或者jar的完全路径名\n\n{% asset_img jps3.png [jps3.png] %}\n\n\n# jstat\n\njstat -gc PID :查看java进程的内存和GC情况\n\n{% asset_img stat1.png [stat1.png]%}\n\njstat -gccapacity PID 堆内存分析\n\njstat -gcnew PID 年轻代GC分析\n\njstat -gcnewcapacity PID 年轻代内存分析\n\njstat -gcold PID 老年代GC分析\n\njstat -gcoldcapacity PID 老年代内存分析\n\njstat -gcmetacapacity PID 元数据内存分析\n\n\n\n","slug":"jvm/java-jvm-命令的使用","published":1,"updated":"2020-12-03T05:35:39.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y05000c54vi16ie4gz8","content":"<h1 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h1><p>jps是JavaVirtual Machine Process Status Tool的缩写，是java提供的查看进程的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令格式：jps [options ] [ hostid ] </span><br><span class=\"line\"></span><br><span class=\"line\">[options]选项 ：</span><br><span class=\"line\">-q：仅输出VM标识符，不包括classname,jar name,arguments in main method </span><br><span class=\"line\">-m：输出main method的参数 </span><br><span class=\"line\">-l：输出完全的包名，应用主类名，jar的完全路径名 </span><br><span class=\"line\">-v：输出jvm参数 </span><br><span class=\"line\">-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags&#x3D;所指定的文件 </span><br><span class=\"line\">-Joption：传递参数到vm,例如:-J-Xms512m</span><br><span class=\"line\"></span><br><span class=\"line\">[hostid]：</span><br><span class=\"line\">[protocol:][[&#x2F;&#x2F;]hostname][:port][&#x2F;servername]</span><br><span class=\"line\">命令的输出格式 ：</span><br><span class=\"line\">lvmid [ [ classname| JARfilename | &quot;Unknown&quot;] [ arg* ] [ jvmarg* ] ]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-jps\"><a href=\"#1-jps\" class=\"headerlink\" title=\"1. jps\"></a>1. jps</h2><img src=\"/2020/11/26/jvm/java-jvm-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/jps1.png\" class=\"\" title=\"[jps1.png]\">\n\n<h2 id=\"2-jps-q-仅仅显示java进程号\"><a href=\"#2-jps-q-仅仅显示java进程号\" class=\"headerlink\" title=\"2. jps -q :仅仅显示java进程号\"></a>2. jps -q :仅仅显示java进程号</h2><img src=\"/2020/11/26/jvm/java-jvm-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/jps2.png\" class=\"\" title=\"[jps2.png]\">\n\n<h2 id=\"3-jps-l-输出主类或者jar的完全路径名\"><a href=\"#3-jps-l-输出主类或者jar的完全路径名\" class=\"headerlink\" title=\"3. jps -l :输出主类或者jar的完全路径名\"></a>3. jps -l :输出主类或者jar的完全路径名</h2><img src=\"/2020/11/26/jvm/java-jvm-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/jps3.png\" class=\"\" title=\"[jps3.png]\">\n\n\n<h1 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h1><p>jstat -gc PID :查看java进程的内存和GC情况</p>\n<img src=\"/2020/11/26/jvm/java-jvm-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/stat1.png\" class=\"\" title=\"[stat1.png]\">\n\n<p>jstat -gccapacity PID 堆内存分析</p>\n<p>jstat -gcnew PID 年轻代GC分析</p>\n<p>jstat -gcnewcapacity PID 年轻代内存分析</p>\n<p>jstat -gcold PID 老年代GC分析</p>\n<p>jstat -gcoldcapacity PID 老年代内存分析</p>\n<p>jstat -gcmetacapacity PID 元数据内存分析</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h1><p>jps是JavaVirtual Machine Process Status Tool的缩写，是java提供的查看进程的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令格式：jps [options ] [ hostid ] </span><br><span class=\"line\"></span><br><span class=\"line\">[options]选项 ：</span><br><span class=\"line\">-q：仅输出VM标识符，不包括classname,jar name,arguments in main method </span><br><span class=\"line\">-m：输出main method的参数 </span><br><span class=\"line\">-l：输出完全的包名，应用主类名，jar的完全路径名 </span><br><span class=\"line\">-v：输出jvm参数 </span><br><span class=\"line\">-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags&#x3D;所指定的文件 </span><br><span class=\"line\">-Joption：传递参数到vm,例如:-J-Xms512m</span><br><span class=\"line\"></span><br><span class=\"line\">[hostid]：</span><br><span class=\"line\">[protocol:][[&#x2F;&#x2F;]hostname][:port][&#x2F;servername]</span><br><span class=\"line\">命令的输出格式 ：</span><br><span class=\"line\">lvmid [ [ classname| JARfilename | &quot;Unknown&quot;] [ arg* ] [ jvmarg* ] ]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-jps\"><a href=\"#1-jps\" class=\"headerlink\" title=\"1. jps\"></a>1. jps</h2><img src=\"/2020/11/26/jvm/java-jvm-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/jps1.png\" class=\"\" title=\"[jps1.png]\">\n\n<h2 id=\"2-jps-q-仅仅显示java进程号\"><a href=\"#2-jps-q-仅仅显示java进程号\" class=\"headerlink\" title=\"2. jps -q :仅仅显示java进程号\"></a>2. jps -q :仅仅显示java进程号</h2><img src=\"/2020/11/26/jvm/java-jvm-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/jps2.png\" class=\"\" title=\"[jps2.png]\">\n\n<h2 id=\"3-jps-l-输出主类或者jar的完全路径名\"><a href=\"#3-jps-l-输出主类或者jar的完全路径名\" class=\"headerlink\" title=\"3. jps -l :输出主类或者jar的完全路径名\"></a>3. jps -l :输出主类或者jar的完全路径名</h2><img src=\"/2020/11/26/jvm/java-jvm-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/jps3.png\" class=\"\" title=\"[jps3.png]\">\n\n\n<h1 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h1><p>jstat -gc PID :查看java进程的内存和GC情况</p>\n<img src=\"/2020/11/26/jvm/java-jvm-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/stat1.png\" class=\"\" title=\"[stat1.png]\">\n\n<p>jstat -gccapacity PID 堆内存分析</p>\n<p>jstat -gcnew PID 年轻代GC分析</p>\n<p>jstat -gcnewcapacity PID 年轻代内存分析</p>\n<p>jstat -gcold PID 老年代GC分析</p>\n<p>jstat -gcoldcapacity PID 老年代内存分析</p>\n<p>jstat -gcmetacapacity PID 元数据内存分析</p>\n"},{"title":"java-jvm-手动实现yangGC","date":"2020-11-24T16:20:03.000Z","_content":"","source":"_posts/jvm/java-jvm-手动实现yangGC.md","raw":"---\ntitle: java-jvm-手动实现yangGC\ndate: 2020-11-25 00:20:03\ntags:\n---\n","slug":"jvm/java-jvm-手动实现yangGC","published":1,"updated":"2020-11-26T03:21:43.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y07000e54vic7ui1eb1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"再学SpringBoot-搭建第一个springboot项目","date":"2019-05-29T08:59:41.000Z","_content":"springboot 已经使用了两年，但是对springboot没有系统的学习过，所以打算系统的学习一下Springboot。以较为学，应该是最有效的学习方法，所以通过边学边写教程的方式，来学习。\n\n\n## 环境\n\n- jdk:1.8\n- springboot:2.0.1\n- 开发工具：idea\n- 构建工具：maven\n\n## 项目搭建\n\nspringboot为开发者提供了模板，所以开发者可以通过网站直接创建一个springboot项目。这里我通过idea直接创建第一个springboot项目\n\n### 1 步骤\n\n点击File -> new - project，选择Spring Initializr。\n![springboot1.png](./springboot1.png)\n输入信息\n![springboot2.png](./springboot2.png)\n在这里我们可以选择需要的jar包，创建时会自动为我们引入，不在需要自己手动去添加。同时可以选择springboot的版本。\n![springboot3.png](./springboot3.png)\n选择路径，创建完成。\n![springboot3.png](./springboot3.png)\n\n\n### 2.目录结构\n\n```\n- src\n    -main\n        -java\n            -package\n                #主函数，启动类，运行它如果运行了 Tomcat、Jetty、Undertow 等容器\n                -SpringbootApplication\t\n        -resouces\n            #存放静态资源 js/css/images 等\n            - statics\n            #存放 html 模板文件\n            - templates\n            #主要的配置文件，SpringBoot启动时候会自动加载application.yml/application.properties\t\t\n            - application.yml\n    #测试文件存放目录\t\t\n    -test\n # pom.xml 文件是Maven构建的基础，里面包含了我们所依赖JAR和Plugin的信息\n- pom\n```","source":"_posts/springboot/springboot-frist.md","raw":"---\ntitle: 再学SpringBoot-搭建第一个springboot项目\ndate: 2019-05-29 16:59:41\ncategories: \n    - SpringBoot\ntags: \n    - SpringBoot\n---\nspringboot 已经使用了两年，但是对springboot没有系统的学习过，所以打算系统的学习一下Springboot。以较为学，应该是最有效的学习方法，所以通过边学边写教程的方式，来学习。\n\n\n## 环境\n\n- jdk:1.8\n- springboot:2.0.1\n- 开发工具：idea\n- 构建工具：maven\n\n## 项目搭建\n\nspringboot为开发者提供了模板，所以开发者可以通过网站直接创建一个springboot项目。这里我通过idea直接创建第一个springboot项目\n\n### 1 步骤\n\n点击File -> new - project，选择Spring Initializr。\n![springboot1.png](./springboot1.png)\n输入信息\n![springboot2.png](./springboot2.png)\n在这里我们可以选择需要的jar包，创建时会自动为我们引入，不在需要自己手动去添加。同时可以选择springboot的版本。\n![springboot3.png](./springboot3.png)\n选择路径，创建完成。\n![springboot3.png](./springboot3.png)\n\n\n### 2.目录结构\n\n```\n- src\n    -main\n        -java\n            -package\n                #主函数，启动类，运行它如果运行了 Tomcat、Jetty、Undertow 等容器\n                -SpringbootApplication\t\n        -resouces\n            #存放静态资源 js/css/images 等\n            - statics\n            #存放 html 模板文件\n            - templates\n            #主要的配置文件，SpringBoot启动时候会自动加载application.yml/application.properties\t\t\n            - application.yml\n    #测试文件存放目录\t\t\n    -test\n # pom.xml 文件是Maven构建的基础，里面包含了我们所依赖JAR和Plugin的信息\n- pom\n```","slug":"springboot/springboot-frist","published":1,"updated":"2020-11-03T16:14:15.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y09000j54vi370l2tma","content":"<p>springboot 已经使用了两年，但是对springboot没有系统的学习过，所以打算系统的学习一下Springboot。以较为学，应该是最有效的学习方法，所以通过边学边写教程的方式，来学习。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>jdk:1.8</li>\n<li>springboot:2.0.1</li>\n<li>开发工具：idea</li>\n<li>构建工具：maven</li>\n</ul>\n<h2 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h2><p>springboot为开发者提供了模板，所以开发者可以通过网站直接创建一个springboot项目。这里我通过idea直接创建第一个springboot项目</p>\n<h3 id=\"1-步骤\"><a href=\"#1-步骤\" class=\"headerlink\" title=\"1 步骤\"></a>1 步骤</h3><p>点击File -&gt; new - project，选择Spring Initializr。<br><img src=\"./springboot1.png\" alt=\"springboot1.png\"><br>输入信息<br><img src=\"./springboot2.png\" alt=\"springboot2.png\"><br>在这里我们可以选择需要的jar包，创建时会自动为我们引入，不在需要自己手动去添加。同时可以选择springboot的版本。<br><img src=\"./springboot3.png\" alt=\"springboot3.png\"><br>选择路径，创建完成。<br><img src=\"./springboot3.png\" alt=\"springboot3.png\"></p>\n<h3 id=\"2-目录结构\"><a href=\"#2-目录结构\" class=\"headerlink\" title=\"2.目录结构\"></a>2.目录结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">    -main</span><br><span class=\"line\">        -java</span><br><span class=\"line\">            -package</span><br><span class=\"line\">                #主函数，启动类，运行它如果运行了 Tomcat、Jetty、Undertow 等容器</span><br><span class=\"line\">                -SpringbootApplication\t</span><br><span class=\"line\">        -resouces</span><br><span class=\"line\">            #存放静态资源 js&#x2F;css&#x2F;images 等</span><br><span class=\"line\">            - statics</span><br><span class=\"line\">            #存放 html 模板文件</span><br><span class=\"line\">            - templates</span><br><span class=\"line\">            #主要的配置文件，SpringBoot启动时候会自动加载application.yml&#x2F;application.properties\t\t</span><br><span class=\"line\">            - application.yml</span><br><span class=\"line\">    #测试文件存放目录\t\t</span><br><span class=\"line\">    -test</span><br><span class=\"line\"> # pom.xml 文件是Maven构建的基础，里面包含了我们所依赖JAR和Plugin的信息</span><br><span class=\"line\">- pom</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>springboot 已经使用了两年，但是对springboot没有系统的学习过，所以打算系统的学习一下Springboot。以较为学，应该是最有效的学习方法，所以通过边学边写教程的方式，来学习。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>jdk:1.8</li>\n<li>springboot:2.0.1</li>\n<li>开发工具：idea</li>\n<li>构建工具：maven</li>\n</ul>\n<h2 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h2><p>springboot为开发者提供了模板，所以开发者可以通过网站直接创建一个springboot项目。这里我通过idea直接创建第一个springboot项目</p>\n<h3 id=\"1-步骤\"><a href=\"#1-步骤\" class=\"headerlink\" title=\"1 步骤\"></a>1 步骤</h3><p>点击File -&gt; new - project，选择Spring Initializr。<br><img src=\"./springboot1.png\" alt=\"springboot1.png\"><br>输入信息<br><img src=\"./springboot2.png\" alt=\"springboot2.png\"><br>在这里我们可以选择需要的jar包，创建时会自动为我们引入，不在需要自己手动去添加。同时可以选择springboot的版本。<br><img src=\"./springboot3.png\" alt=\"springboot3.png\"><br>选择路径，创建完成。<br><img src=\"./springboot3.png\" alt=\"springboot3.png\"></p>\n<h3 id=\"2-目录结构\"><a href=\"#2-目录结构\" class=\"headerlink\" title=\"2.目录结构\"></a>2.目录结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- src</span><br><span class=\"line\">    -main</span><br><span class=\"line\">        -java</span><br><span class=\"line\">            -package</span><br><span class=\"line\">                #主函数，启动类，运行它如果运行了 Tomcat、Jetty、Undertow 等容器</span><br><span class=\"line\">                -SpringbootApplication\t</span><br><span class=\"line\">        -resouces</span><br><span class=\"line\">            #存放静态资源 js&#x2F;css&#x2F;images 等</span><br><span class=\"line\">            - statics</span><br><span class=\"line\">            #存放 html 模板文件</span><br><span class=\"line\">            - templates</span><br><span class=\"line\">            #主要的配置文件，SpringBoot启动时候会自动加载application.yml&#x2F;application.properties\t\t</span><br><span class=\"line\">            - application.yml</span><br><span class=\"line\">    #测试文件存放目录\t\t</span><br><span class=\"line\">    -test</span><br><span class=\"line\"> # pom.xml 文件是Maven构建的基础，里面包含了我们所依赖JAR和Plugin的信息</span><br><span class=\"line\">- pom</span><br></pre></td></tr></table></figure>"},{"title":"再学SpringBoot-springboot配置文件的使用","date":"2019-06-12T13:23:00.000Z","_content":"\nspringboot最大的改进就是简化的大量的配置，但是并不是完全的免配置，本文就介绍一下springboot是如何使用配置文件\n\n### 1. 配置文件\n\nspringboot的配置文件放在resources文件夹中，支持两种文件格式，一种是常规的properties文件，另外一种就是 yml 文件。本文主要使用yml文件。\n\n\n","source":"_posts/springboot/springboot-yml.md","raw":"---\ntitle: 再学SpringBoot-springboot配置文件的使用\ndate: 2019-06-12 21:23:00\ncategories: \n    - SpringBoot\ntags: \n    - SpringBoot\n---\n\nspringboot最大的改进就是简化的大量的配置，但是并不是完全的免配置，本文就介绍一下springboot是如何使用配置文件\n\n### 1. 配置文件\n\nspringboot的配置文件放在resources文件夹中，支持两种文件格式，一种是常规的properties文件，另外一种就是 yml 文件。本文主要使用yml文件。\n\n\n","slug":"springboot/springboot-yml","published":1,"updated":"2020-11-03T16:14:15.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0a000m54vif8b94c32","content":"<p>springboot最大的改进就是简化的大量的配置，但是并不是完全的免配置，本文就介绍一下springboot是如何使用配置文件</p>\n<h3 id=\"1-配置文件\"><a href=\"#1-配置文件\" class=\"headerlink\" title=\"1. 配置文件\"></a>1. 配置文件</h3><p>springboot的配置文件放在resources文件夹中，支持两种文件格式，一种是常规的properties文件，另外一种就是 yml 文件。本文主要使用yml文件。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>springboot最大的改进就是简化的大量的配置，但是并不是完全的免配置，本文就介绍一下springboot是如何使用配置文件</p>\n<h3 id=\"1-配置文件\"><a href=\"#1-配置文件\" class=\"headerlink\" title=\"1. 配置文件\"></a>1. 配置文件</h3><p>springboot的配置文件放在resources文件夹中，支持两种文件格式，一种是常规的properties文件，另外一种就是 yml 文件。本文主要使用yml文件。</p>\n"},{"title":"搭建个人博客","date":"2019-05-17T05:54:09.000Z","_content":"\n第一次搭建自己的博客，所以想要记录下，搭建的完整过程，方便想要搭建的小白少走弯路。\n\n\n## 所需材料\n\n- 博客的框架使用的是 hexo\n- hexo 需要依托在 node.js ，所以需要先安装nodejs\n- GitHubPage: 网站在gitHub上托管\n- git \n\n\n\n## 步骤\n\n### 1.安装node.js\n\n打开官网：https://nodejs.org/en/ , 下载稳定版本的进行安装。\n\n{% asset_img nodejs.png [nodejs.png] %}\n\n\n安装过程 我就忽略了哈， 这个不会 就真的小白了，哈哈（其实是作者懒的在操作一遍   :laughing: ， 有空补上）\n\n### 2.安装 git\n\n因为需要将我们的静态网站，部署到github上， 所有需要现在本地安装git.\n\n### 3.下载并安装hexo\n\n\n### 4.创建博客目录\n\n新建一个目录，执行下面命令\n\n```\nhexo init blog\n```\n执行完之后，会自动创建一个hexo目录\n\n\n从[hexo](https://hexo.io/themes/) 选择自己喜欢的主体，下载到本地。放在\\themes目录下。\n\n### 5.修改配置文件根目录下的 _config.yml\n\n1. 使用自己下载的主题\n\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: ayer\n```\n\n2. 在github或者码云上新建一个仓库，仓库名需要和用户名相同\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: https://gitee.com/xxx/xxxx.git\n  branch: master\n```\n\n### 6.安装插件\n\n\n\n在博客根目录下安装部署插件\n```\nnpm install hexo-deployer-git --save\n```\n\n\n### 4.常用操作\n\n- 创建新的文章\n```\nhexo n \"firstBlog\"\n```\n    会在_posts文件加下创建出一个文件夹（存储文章中图片），和一个md文件,使用下面代码可以引入图片\n```\n ![newfirstBlog.png](newfirstBlog.png)\n```\n![newfirstBlog.png](newfirstBlog.png)\n\n\n\n部署命令\n\nhexo clean # 清除已生成文件及缓存\nhexo generate # 生成静态页面，简写做hexo g\nhexo server # 启动本地WEB服务器，简写做hexo s\n\nhexo clean \"&&\" hexo deploy \n\nhexo clean \"&&\" hexo generate \"&&\" hexo deploy \n\n\n## 访问地址\n\n```\nhttps://hhass.gitee.io\n```\n\n\n\n\n\n","source":"_posts/blog/firstBlog.md","raw":"---\ntitle: 搭建个人博客\ndate: 2019-05-17 13:54:09\ncategories: \n    - 记录\ntags: \n    - 博客\n---\n\n第一次搭建自己的博客，所以想要记录下，搭建的完整过程，方便想要搭建的小白少走弯路。\n\n\n## 所需材料\n\n- 博客的框架使用的是 hexo\n- hexo 需要依托在 node.js ，所以需要先安装nodejs\n- GitHubPage: 网站在gitHub上托管\n- git \n\n\n\n## 步骤\n\n### 1.安装node.js\n\n打开官网：https://nodejs.org/en/ , 下载稳定版本的进行安装。\n\n{% asset_img nodejs.png [nodejs.png] %}\n\n\n安装过程 我就忽略了哈， 这个不会 就真的小白了，哈哈（其实是作者懒的在操作一遍   :laughing: ， 有空补上）\n\n### 2.安装 git\n\n因为需要将我们的静态网站，部署到github上， 所有需要现在本地安装git.\n\n### 3.下载并安装hexo\n\n\n### 4.创建博客目录\n\n新建一个目录，执行下面命令\n\n```\nhexo init blog\n```\n执行完之后，会自动创建一个hexo目录\n\n\n从[hexo](https://hexo.io/themes/) 选择自己喜欢的主体，下载到本地。放在\\themes目录下。\n\n### 5.修改配置文件根目录下的 _config.yml\n\n1. 使用自己下载的主题\n\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: ayer\n```\n\n2. 在github或者码云上新建一个仓库，仓库名需要和用户名相同\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: https://gitee.com/xxx/xxxx.git\n  branch: master\n```\n\n### 6.安装插件\n\n\n\n在博客根目录下安装部署插件\n```\nnpm install hexo-deployer-git --save\n```\n\n\n### 4.常用操作\n\n- 创建新的文章\n```\nhexo n \"firstBlog\"\n```\n    会在_posts文件加下创建出一个文件夹（存储文章中图片），和一个md文件,使用下面代码可以引入图片\n```\n ![newfirstBlog.png](newfirstBlog.png)\n```\n![newfirstBlog.png](newfirstBlog.png)\n\n\n\n部署命令\n\nhexo clean # 清除已生成文件及缓存\nhexo generate # 生成静态页面，简写做hexo g\nhexo server # 启动本地WEB服务器，简写做hexo s\n\nhexo clean \"&&\" hexo deploy \n\nhexo clean \"&&\" hexo generate \"&&\" hexo deploy \n\n\n## 访问地址\n\n```\nhttps://hhass.gitee.io\n```\n\n\n\n\n\n","slug":"blog/firstBlog","published":1,"updated":"2020-11-26T03:21:43.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0c000r54vi9vxa6nso","content":"<p>第一次搭建自己的博客，所以想要记录下，搭建的完整过程，方便想要搭建的小白少走弯路。</p>\n<h2 id=\"所需材料\"><a href=\"#所需材料\" class=\"headerlink\" title=\"所需材料\"></a>所需材料</h2><ul>\n<li>博客的框架使用的是 hexo</li>\n<li>hexo 需要依托在 node.js ，所以需要先安装nodejs</li>\n<li>GitHubPage: 网站在gitHub上托管</li>\n<li>git </li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"1-安装node-js\"><a href=\"#1-安装node-js\" class=\"headerlink\" title=\"1.安装node.js\"></a>1.安装node.js</h3><p>打开官网：<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a> , 下载稳定版本的进行安装。</p>\n<img src=\"/2019/05/17/blog/firstBlog/nodejs.png\" class=\"\" title=\"[nodejs.png]\">\n\n\n<p>安装过程 我就忽略了哈， 这个不会 就真的小白了，哈哈（其实是作者懒的在操作一遍   :laughing: ， 有空补上）</p>\n<h3 id=\"2-安装-git\"><a href=\"#2-安装-git\" class=\"headerlink\" title=\"2.安装 git\"></a>2.安装 git</h3><p>因为需要将我们的静态网站，部署到github上， 所有需要现在本地安装git.</p>\n<h3 id=\"3-下载并安装hexo\"><a href=\"#3-下载并安装hexo\" class=\"headerlink\" title=\"3.下载并安装hexo\"></a>3.下载并安装hexo</h3><h3 id=\"4-创建博客目录\"><a href=\"#4-创建博客目录\" class=\"headerlink\" title=\"4.创建博客目录\"></a>4.创建博客目录</h3><p>新建一个目录，执行下面命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n<p>执行完之后，会自动创建一个hexo目录</p>\n<p>从<a href=\"https://hexo.io/themes/\">hexo</a> 选择自己喜欢的主体，下载到本地。放在\\themes目录下。</p>\n<h3 id=\"5-修改配置文件根目录下的-config-yml\"><a href=\"#5-修改配置文件根目录下的-config-yml\" class=\"headerlink\" title=\"5.修改配置文件根目录下的 _config.yml\"></a>5.修改配置文件根目录下的 _config.yml</h3><ol>\n<li>使用自己下载的主题</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class=\"line\">theme: ayer</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在github或者码云上新建一个仓库，仓库名需要和用户名相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https:&#x2F;&#x2F;gitee.com&#x2F;xxx&#x2F;xxxx.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-安装插件\"><a href=\"#6-安装插件\" class=\"headerlink\" title=\"6.安装插件\"></a>6.安装插件</h3><p>在博客根目录下安装部署插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-常用操作\"><a href=\"#4-常用操作\" class=\"headerlink\" title=\"4.常用操作\"></a>4.常用操作</h3><ul>\n<li>创建新的文章<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n &quot;firstBlog&quot;</span><br></pre></td></tr></table></figure>\n  会在_posts文件加下创建出一个文件夹（存储文章中图片），和一个md文件,使用下面代码可以引入图片<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![newfirstBlog.png](newfirstBlog.png)</span><br></pre></td></tr></table></figure>\n<img src=\"newfirstBlog.png\" alt=\"newfirstBlog.png\"></li>\n</ul>\n<p>部署命令</p>\n<p>hexo clean # 清除已生成文件及缓存<br>hexo generate # 生成静态页面，简写做hexo g<br>hexo server # 启动本地WEB服务器，简写做hexo s</p>\n<p>hexo clean “&amp;&amp;” hexo deploy </p>\n<p>hexo clean “&amp;&amp;” hexo generate “&amp;&amp;” hexo deploy </p>\n<h2 id=\"访问地址\"><a href=\"#访问地址\" class=\"headerlink\" title=\"访问地址\"></a>访问地址</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https:&#x2F;&#x2F;hhass.gitee.io</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>第一次搭建自己的博客，所以想要记录下，搭建的完整过程，方便想要搭建的小白少走弯路。</p>\n<h2 id=\"所需材料\"><a href=\"#所需材料\" class=\"headerlink\" title=\"所需材料\"></a>所需材料</h2><ul>\n<li>博客的框架使用的是 hexo</li>\n<li>hexo 需要依托在 node.js ，所以需要先安装nodejs</li>\n<li>GitHubPage: 网站在gitHub上托管</li>\n<li>git </li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"1-安装node-js\"><a href=\"#1-安装node-js\" class=\"headerlink\" title=\"1.安装node.js\"></a>1.安装node.js</h3><p>打开官网：<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a> , 下载稳定版本的进行安装。</p>\n<img src=\"/2019/05/17/blog/firstBlog/nodejs.png\" class=\"\" title=\"[nodejs.png]\">\n\n\n<p>安装过程 我就忽略了哈， 这个不会 就真的小白了，哈哈（其实是作者懒的在操作一遍   :laughing: ， 有空补上）</p>\n<h3 id=\"2-安装-git\"><a href=\"#2-安装-git\" class=\"headerlink\" title=\"2.安装 git\"></a>2.安装 git</h3><p>因为需要将我们的静态网站，部署到github上， 所有需要现在本地安装git.</p>\n<h3 id=\"3-下载并安装hexo\"><a href=\"#3-下载并安装hexo\" class=\"headerlink\" title=\"3.下载并安装hexo\"></a>3.下载并安装hexo</h3><h3 id=\"4-创建博客目录\"><a href=\"#4-创建博客目录\" class=\"headerlink\" title=\"4.创建博客目录\"></a>4.创建博客目录</h3><p>新建一个目录，执行下面命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n<p>执行完之后，会自动创建一个hexo目录</p>\n<p>从<a href=\"https://hexo.io/themes/\">hexo</a> 选择自己喜欢的主体，下载到本地。放在\\themes目录下。</p>\n<h3 id=\"5-修改配置文件根目录下的-config-yml\"><a href=\"#5-修改配置文件根目录下的-config-yml\" class=\"headerlink\" title=\"5.修改配置文件根目录下的 _config.yml\"></a>5.修改配置文件根目录下的 _config.yml</h3><ol>\n<li>使用自己下载的主题</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class=\"line\">theme: ayer</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在github或者码云上新建一个仓库，仓库名需要和用户名相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https:&#x2F;&#x2F;gitee.com&#x2F;xxx&#x2F;xxxx.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-安装插件\"><a href=\"#6-安装插件\" class=\"headerlink\" title=\"6.安装插件\"></a>6.安装插件</h3><p>在博客根目录下安装部署插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-常用操作\"><a href=\"#4-常用操作\" class=\"headerlink\" title=\"4.常用操作\"></a>4.常用操作</h3><ul>\n<li>创建新的文章<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo n &quot;firstBlog&quot;</span><br></pre></td></tr></table></figure>\n  会在_posts文件加下创建出一个文件夹（存储文章中图片），和一个md文件,使用下面代码可以引入图片<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![newfirstBlog.png](newfirstBlog.png)</span><br></pre></td></tr></table></figure>\n<img src=\"newfirstBlog.png\" alt=\"newfirstBlog.png\"></li>\n</ul>\n<p>部署命令</p>\n<p>hexo clean # 清除已生成文件及缓存<br>hexo generate # 生成静态页面，简写做hexo g<br>hexo server # 启动本地WEB服务器，简写做hexo s</p>\n<p>hexo clean “&amp;&amp;” hexo deploy </p>\n<p>hexo clean “&amp;&amp;” hexo generate “&amp;&amp;” hexo deploy </p>\n<h2 id=\"访问地址\"><a href=\"#访问地址\" class=\"headerlink\" title=\"访问地址\"></a>访问地址</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https:&#x2F;&#x2F;hhass.gitee.io</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"title":"java内存分配与回收策略","date":"2019-05-28T07:43:05.000Z","_content":"\n大多数的情况下，对象在新生代Eden区中分配。当Eden没有足够的空间进行分配时，虚拟机会触发一次Minor GC。\n\n大对象是指需要大量连续内存空间的java对象，最典型的大对象是那种很长的字符串以及数组。\n\n-XX:pretenureSizeThreshold参数，令大于设置值的对象直接分配到老年代中，从而避免对象在Eden区与Survivor区之间发生大量复制。\n\n\n虚拟机通常采用分代收集的思想来管理内存。虚拟机为每个对象定义了一个对象年龄计数器，如果对象在Eden区经过了一次Minor GC 还存活， 那么该对象会进入Survivor中，并且age设置为1。每经过一次Minor GC age都会加1，直到达到一定程度（默认是15岁），会进入到老年代。年龄阈值通过参数-XX:MaxTenuringThreshold设置。\n\n为了更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了参数才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的1半，年龄大于或者等于改年龄的对象接可以直接进入老年代，不用等到MaxTenuringThreshold中的年龄要求。\n\n<font color= \"red\">注：</font>\n```\nMinor GC(新生代GC)：指发生在新生代的垃圾收集动作，触发频率频繁，回收速度也比较快。\n\nMajor GC/Full GC(老年代GC)：指发生在老年代的GC，出现Major GC，经常伴随至少一次的Minor GC。\n```","source":"_posts/jvm/java-jvm-gc-memory.md","raw":"---\ntitle: java内存分配与回收策略\ndate: 2019-05-28 15:43:05\ncategories: \n    - JAVA_JVM\ntags: \n    - JVM\n---\n\n大多数的情况下，对象在新生代Eden区中分配。当Eden没有足够的空间进行分配时，虚拟机会触发一次Minor GC。\n\n大对象是指需要大量连续内存空间的java对象，最典型的大对象是那种很长的字符串以及数组。\n\n-XX:pretenureSizeThreshold参数，令大于设置值的对象直接分配到老年代中，从而避免对象在Eden区与Survivor区之间发生大量复制。\n\n\n虚拟机通常采用分代收集的思想来管理内存。虚拟机为每个对象定义了一个对象年龄计数器，如果对象在Eden区经过了一次Minor GC 还存活， 那么该对象会进入Survivor中，并且age设置为1。每经过一次Minor GC age都会加1，直到达到一定程度（默认是15岁），会进入到老年代。年龄阈值通过参数-XX:MaxTenuringThreshold设置。\n\n为了更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了参数才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的1半，年龄大于或者等于改年龄的对象接可以直接进入老年代，不用等到MaxTenuringThreshold中的年龄要求。\n\n<font color= \"red\">注：</font>\n```\nMinor GC(新生代GC)：指发生在新生代的垃圾收集动作，触发频率频繁，回收速度也比较快。\n\nMajor GC/Full GC(老年代GC)：指发生在老年代的GC，出现Major GC，经常伴随至少一次的Minor GC。\n```","slug":"jvm/java-jvm-gc-memory","published":1,"updated":"2020-11-03T16:13:26.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0e000u54vi8gp261rl","content":"<p>大多数的情况下，对象在新生代Eden区中分配。当Eden没有足够的空间进行分配时，虚拟机会触发一次Minor GC。</p>\n<p>大对象是指需要大量连续内存空间的java对象，最典型的大对象是那种很长的字符串以及数组。</p>\n<p>-XX:pretenureSizeThreshold参数，令大于设置值的对象直接分配到老年代中，从而避免对象在Eden区与Survivor区之间发生大量复制。</p>\n<p>虚拟机通常采用分代收集的思想来管理内存。虚拟机为每个对象定义了一个对象年龄计数器，如果对象在Eden区经过了一次Minor GC 还存活， 那么该对象会进入Survivor中，并且age设置为1。每经过一次Minor GC age都会加1，直到达到一定程度（默认是15岁），会进入到老年代。年龄阈值通过参数-XX:MaxTenuringThreshold设置。</p>\n<p>为了更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了参数才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的1半，年龄大于或者等于改年龄的对象接可以直接进入老年代，不用等到MaxTenuringThreshold中的年龄要求。</p>\n<p><font color= \"red\">注：</font></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Minor GC(新生代GC)：指发生在新生代的垃圾收集动作，触发频率频繁，回收速度也比较快。</span><br><span class=\"line\"></span><br><span class=\"line\">Major GC&#x2F;Full GC(老年代GC)：指发生在老年代的GC，出现Major GC，经常伴随至少一次的Minor GC。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>大多数的情况下，对象在新生代Eden区中分配。当Eden没有足够的空间进行分配时，虚拟机会触发一次Minor GC。</p>\n<p>大对象是指需要大量连续内存空间的java对象，最典型的大对象是那种很长的字符串以及数组。</p>\n<p>-XX:pretenureSizeThreshold参数，令大于设置值的对象直接分配到老年代中，从而避免对象在Eden区与Survivor区之间发生大量复制。</p>\n<p>虚拟机通常采用分代收集的思想来管理内存。虚拟机为每个对象定义了一个对象年龄计数器，如果对象在Eden区经过了一次Minor GC 还存活， 那么该对象会进入Survivor中，并且age设置为1。每经过一次Minor GC age都会加1，直到达到一定程度（默认是15岁），会进入到老年代。年龄阈值通过参数-XX:MaxTenuringThreshold设置。</p>\n<p>为了更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了参数才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的1半，年龄大于或者等于改年龄的对象接可以直接进入老年代，不用等到MaxTenuringThreshold中的年龄要求。</p>\n<p><font color= \"red\">注：</font></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Minor GC(新生代GC)：指发生在新生代的垃圾收集动作，触发频率频繁，回收速度也比较快。</span><br><span class=\"line\"></span><br><span class=\"line\">Major GC&#x2F;Full GC(老年代GC)：指发生在老年代的GC，出现Major GC，经常伴随至少一次的Minor GC。</span><br></pre></td></tr></table></figure>"},{"title":"tomcat_1_http协议","date":"2020-12-03T05:34:53.000Z","_content":"\ntomcat 本身就是一个 HTTP服务器+Servlet容器。在学习Tomcat之前，先说一下HTTP协议。\n\nHTTP协议是浏览器与服务器之间的数据传输协议，作为应用层协议。基于TCP/IP协议来传输数据的，不涉及数据包传输，主要规定了客户端与服务器之鉴啊的通信格式。\n\n## HTTP工作原理\n\n如图是HTTP的请求过程\n\n{% asset_img http原理.png [http原理.png] %}\n\n\n1. 用户通过浏览器向服务器发起TCP连接请求，通过三次握手，建立连接\n2. 浏览器将请求数据打包成一个HTTP协议格式的数据包，发送服务器。\n3. 服务器拿到数据包后，通过HTTP协议格式解包，得知客户端意图。\n4. 服务器处理，并生成响应结果，按照HTTP格式打包。推送给浏览器。\n5. 浏览器拿到数据包解析。\n\n\nHTTP请求包括请求行、请求报头、请求正文\n\nHTTP响应包括状态行、响应报头、报文主体","source":"_posts/tomcat/tomcat-1-http协议.md","raw":"---\ntitle: tomcat_1_http协议\ndate: 2020-12-03 13:34:53\ncategories: \n    - tomcat\ntags: \n    - tomcat\n---\n\ntomcat 本身就是一个 HTTP服务器+Servlet容器。在学习Tomcat之前，先说一下HTTP协议。\n\nHTTP协议是浏览器与服务器之间的数据传输协议，作为应用层协议。基于TCP/IP协议来传输数据的，不涉及数据包传输，主要规定了客户端与服务器之鉴啊的通信格式。\n\n## HTTP工作原理\n\n如图是HTTP的请求过程\n\n{% asset_img http原理.png [http原理.png] %}\n\n\n1. 用户通过浏览器向服务器发起TCP连接请求，通过三次握手，建立连接\n2. 浏览器将请求数据打包成一个HTTP协议格式的数据包，发送服务器。\n3. 服务器拿到数据包后，通过HTTP协议格式解包，得知客户端意图。\n4. 服务器处理，并生成响应结果，按照HTTP格式打包。推送给浏览器。\n5. 浏览器拿到数据包解析。\n\n\nHTTP请求包括请求行、请求报头、请求正文\n\nHTTP响应包括状态行、响应报头、报文主体","slug":"tomcat/tomcat-1-http协议","published":1,"updated":"2020-12-03T06:09:38.133Z","_id":"cki8f5y0g000w54vi0yae87xg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>tomcat 本身就是一个 HTTP服务器+Servlet容器。在学习Tomcat之前，先说一下HTTP协议。</p>\n<p>HTTP协议是浏览器与服务器之间的数据传输协议，作为应用层协议。基于TCP/IP协议来传输数据的，不涉及数据包传输，主要规定了客户端与服务器之鉴啊的通信格式。</p>\n<h2 id=\"HTTP工作原理\"><a href=\"#HTTP工作原理\" class=\"headerlink\" title=\"HTTP工作原理\"></a>HTTP工作原理</h2><p>如图是HTTP的请求过程</p>\n<img src=\"/2020/12/03/tomcat/tomcat-1-http%E5%8D%8F%E8%AE%AE/http%E5%8E%9F%E7%90%86.png\" class=\"\" title=\"[http原理.png]\">\n\n\n<ol>\n<li>用户通过浏览器向服务器发起TCP连接请求，通过三次握手，建立连接</li>\n<li>浏览器将请求数据打包成一个HTTP协议格式的数据包，发送服务器。</li>\n<li>服务器拿到数据包后，通过HTTP协议格式解包，得知客户端意图。</li>\n<li>服务器处理，并生成响应结果，按照HTTP格式打包。推送给浏览器。</li>\n<li>浏览器拿到数据包解析。</li>\n</ol>\n<p>HTTP请求包括请求行、请求报头、请求正文</p>\n<p>HTTP响应包括状态行、响应报头、报文主体</p>\n","site":{"data":{}},"excerpt":"","more":"<p>tomcat 本身就是一个 HTTP服务器+Servlet容器。在学习Tomcat之前，先说一下HTTP协议。</p>\n<p>HTTP协议是浏览器与服务器之间的数据传输协议，作为应用层协议。基于TCP/IP协议来传输数据的，不涉及数据包传输，主要规定了客户端与服务器之鉴啊的通信格式。</p>\n<h2 id=\"HTTP工作原理\"><a href=\"#HTTP工作原理\" class=\"headerlink\" title=\"HTTP工作原理\"></a>HTTP工作原理</h2><p>如图是HTTP的请求过程</p>\n<img src=\"/2020/12/03/tomcat/tomcat-1-http%E5%8D%8F%E8%AE%AE/http%E5%8E%9F%E7%90%86.png\" class=\"\" title=\"[http原理.png]\">\n\n\n<ol>\n<li>用户通过浏览器向服务器发起TCP连接请求，通过三次握手，建立连接</li>\n<li>浏览器将请求数据打包成一个HTTP协议格式的数据包，发送服务器。</li>\n<li>服务器拿到数据包后，通过HTTP协议格式解包，得知客户端意图。</li>\n<li>服务器处理，并生成响应结果，按照HTTP格式打包。推送给浏览器。</li>\n<li>浏览器拿到数据包解析。</li>\n</ol>\n<p>HTTP请求包括请求行、请求报头、请求正文</p>\n<p>HTTP响应包括状态行、响应报头、报文主体</p>\n"},{"title":"Vscode使用技巧","date":"2020-11-15T13:55:17.000Z","_content":"\n- 切换tab\n  \n```\nctrl+tab\n```\n","source":"_posts/日常/Vscode使用技巧.md","raw":"---\ntitle: Vscode使用技巧\ndate: 2020-11-15 21:55:17\ncategories: \n    - 日常\n    - 技巧\ntags: \n    - vscode\n    - 技巧\n---\n\n- 切换tab\n  \n```\nctrl+tab\n```\n","slug":"日常/Vscode使用技巧","published":1,"updated":"2020-11-26T03:21:43.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0j001154vi4m0fd1vs","content":"<ul>\n<li>切换tab</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl+tab</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>切换tab</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl+tab</span><br></pre></td></tr></table></figure>\n"},{"title":"jar包冲突","date":"2020-11-04T14:27:02.000Z","_content":"\n&nbsp;&nbsp;明天需要上线需求，所以准备和代码。下班的时候群里就有同事反馈，pre_master分支起不来，直到我准备和代码的时候已经过去2个小时，群里没有动静，心想问题应该已经处理了。为了保险起见还是跑了一遍代码。我擦，没人处理，2个小时过去了，代码一直有人往上和，就是没人处理起不来的问题。好吧，我先看下什么问题吧。。\n\n从报错看在加载rpc client类时报错，看着像resty-pass的jar包的问题，想起有同事升级这个jar的版本的需求，就翻看了jar的说明文档，里面明确提出，升级到6以上的版本，需要注意netty-common的版本需要与之对应。\n\n{% asset_img  启动失败.jpg [启动失败.jpg] %}\n\n通过maven helper工具 发现，确实工程中存在两个版本的netty-common，联系同事，处理问题。搞定，和代码睡觉。\n\n睡觉之前顺便，写一下 __如何处理jar冲突__\n\n### 1.下载idea插件 maven helper\n\n这个就不用太细节了，如下图\n\n{% asset_img maven插件.png [maven插件.png] %}\n\n\n### 2.插件的使用\n\n进入pom文件，会发现，走下角多个一个tab,这个就是maven helper的界面\n\n界面有三个选项：\n\nConflicts（查看冲突）\nAll Dependencies as List（列表形式查看所有依赖）\nAll Dependencies as Tree（树形式查看所有依赖）\n{% asset_img 界面.png [界面.png] %}\n\n\n\n### 3.当出现冲突jar时，右击可以进行处理\n\n当然，处理jar包，还是需要进行评估下，是否会对系统的功能有影响，不能盲目的一顿操作。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/日常/jar包冲突.md","raw":"---\ntitle: jar包冲突\ndate: 2020-11-04 22:27:02\ncategories: \n    - 日常比较\ntags: \n    - 开发环境\n---\n\n&nbsp;&nbsp;明天需要上线需求，所以准备和代码。下班的时候群里就有同事反馈，pre_master分支起不来，直到我准备和代码的时候已经过去2个小时，群里没有动静，心想问题应该已经处理了。为了保险起见还是跑了一遍代码。我擦，没人处理，2个小时过去了，代码一直有人往上和，就是没人处理起不来的问题。好吧，我先看下什么问题吧。。\n\n从报错看在加载rpc client类时报错，看着像resty-pass的jar包的问题，想起有同事升级这个jar的版本的需求，就翻看了jar的说明文档，里面明确提出，升级到6以上的版本，需要注意netty-common的版本需要与之对应。\n\n{% asset_img  启动失败.jpg [启动失败.jpg] %}\n\n通过maven helper工具 发现，确实工程中存在两个版本的netty-common，联系同事，处理问题。搞定，和代码睡觉。\n\n睡觉之前顺便，写一下 __如何处理jar冲突__\n\n### 1.下载idea插件 maven helper\n\n这个就不用太细节了，如下图\n\n{% asset_img maven插件.png [maven插件.png] %}\n\n\n### 2.插件的使用\n\n进入pom文件，会发现，走下角多个一个tab,这个就是maven helper的界面\n\n界面有三个选项：\n\nConflicts（查看冲突）\nAll Dependencies as List（列表形式查看所有依赖）\nAll Dependencies as Tree（树形式查看所有依赖）\n{% asset_img 界面.png [界面.png] %}\n\n\n\n### 3.当出现冲突jar时，右击可以进行处理\n\n当然，处理jar包，还是需要进行评估下，是否会对系统的功能有影响，不能盲目的一顿操作。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"日常/jar包冲突","published":1,"updated":"2020-11-12T09:10:45.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0k001354vi9oq74l4y","content":"<p>&nbsp;&nbsp;明天需要上线需求，所以准备和代码。下班的时候群里就有同事反馈，pre_master分支起不来，直到我准备和代码的时候已经过去2个小时，群里没有动静，心想问题应该已经处理了。为了保险起见还是跑了一遍代码。我擦，没人处理，2个小时过去了，代码一直有人往上和，就是没人处理起不来的问题。好吧，我先看下什么问题吧。。</p>\n<p>从报错看在加载rpc client类时报错，看着像resty-pass的jar包的问题，想起有同事升级这个jar的版本的需求，就翻看了jar的说明文档，里面明确提出，升级到6以上的版本，需要注意netty-common的版本需要与之对应。</p>\n<img src=\"/2020/11/04/%E6%97%A5%E5%B8%B8/jar%E5%8C%85%E5%86%B2%E7%AA%81/%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5.jpg\" class=\"\" title=\"[启动失败.jpg]\">\n\n<p>通过maven helper工具 发现，确实工程中存在两个版本的netty-common，联系同事，处理问题。搞定，和代码睡觉。</p>\n<p>睡觉之前顺便，写一下 <strong>如何处理jar冲突</strong></p>\n<h3 id=\"1-下载idea插件-maven-helper\"><a href=\"#1-下载idea插件-maven-helper\" class=\"headerlink\" title=\"1.下载idea插件 maven helper\"></a>1.下载idea插件 maven helper</h3><p>这个就不用太细节了，如下图</p>\n<img src=\"/2020/11/04/%E6%97%A5%E5%B8%B8/jar%E5%8C%85%E5%86%B2%E7%AA%81/maven%E6%8F%92%E4%BB%B6.png\" class=\"\" title=\"[maven插件.png]\">\n\n\n<h3 id=\"2-插件的使用\"><a href=\"#2-插件的使用\" class=\"headerlink\" title=\"2.插件的使用\"></a>2.插件的使用</h3><p>进入pom文件，会发现，走下角多个一个tab,这个就是maven helper的界面</p>\n<p>界面有三个选项：</p>\n<p>Conflicts（查看冲突）<br>All Dependencies as List（列表形式查看所有依赖）<br>All Dependencies as Tree（树形式查看所有依赖）</p>\n<img src=\"/2020/11/04/%E6%97%A5%E5%B8%B8/jar%E5%8C%85%E5%86%B2%E7%AA%81/%E7%95%8C%E9%9D%A2.png\" class=\"\" title=\"[界面.png]\">\n\n\n\n<h3 id=\"3-当出现冲突jar时，右击可以进行处理\"><a href=\"#3-当出现冲突jar时，右击可以进行处理\" class=\"headerlink\" title=\"3.当出现冲突jar时，右击可以进行处理\"></a>3.当出现冲突jar时，右击可以进行处理</h3><p>当然，处理jar包，还是需要进行评估下，是否会对系统的功能有影响，不能盲目的一顿操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&nbsp;&nbsp;明天需要上线需求，所以准备和代码。下班的时候群里就有同事反馈，pre_master分支起不来，直到我准备和代码的时候已经过去2个小时，群里没有动静，心想问题应该已经处理了。为了保险起见还是跑了一遍代码。我擦，没人处理，2个小时过去了，代码一直有人往上和，就是没人处理起不来的问题。好吧，我先看下什么问题吧。。</p>\n<p>从报错看在加载rpc client类时报错，看着像resty-pass的jar包的问题，想起有同事升级这个jar的版本的需求，就翻看了jar的说明文档，里面明确提出，升级到6以上的版本，需要注意netty-common的版本需要与之对应。</p>\n<img src=\"/2020/11/04/%E6%97%A5%E5%B8%B8/jar%E5%8C%85%E5%86%B2%E7%AA%81/%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5.jpg\" class=\"\" title=\"[启动失败.jpg]\">\n\n<p>通过maven helper工具 发现，确实工程中存在两个版本的netty-common，联系同事，处理问题。搞定，和代码睡觉。</p>\n<p>睡觉之前顺便，写一下 <strong>如何处理jar冲突</strong></p>\n<h3 id=\"1-下载idea插件-maven-helper\"><a href=\"#1-下载idea插件-maven-helper\" class=\"headerlink\" title=\"1.下载idea插件 maven helper\"></a>1.下载idea插件 maven helper</h3><p>这个就不用太细节了，如下图</p>\n<img src=\"/2020/11/04/%E6%97%A5%E5%B8%B8/jar%E5%8C%85%E5%86%B2%E7%AA%81/maven%E6%8F%92%E4%BB%B6.png\" class=\"\" title=\"[maven插件.png]\">\n\n\n<h3 id=\"2-插件的使用\"><a href=\"#2-插件的使用\" class=\"headerlink\" title=\"2.插件的使用\"></a>2.插件的使用</h3><p>进入pom文件，会发现，走下角多个一个tab,这个就是maven helper的界面</p>\n<p>界面有三个选项：</p>\n<p>Conflicts（查看冲突）<br>All Dependencies as List（列表形式查看所有依赖）<br>All Dependencies as Tree（树形式查看所有依赖）</p>\n<img src=\"/2020/11/04/%E6%97%A5%E5%B8%B8/jar%E5%8C%85%E5%86%B2%E7%AA%81/%E7%95%8C%E9%9D%A2.png\" class=\"\" title=\"[界面.png]\">\n\n\n\n<h3 id=\"3-当出现冲突jar时，右击可以进行处理\"><a href=\"#3-当出现冲突jar时，右击可以进行处理\" class=\"headerlink\" title=\"3.当出现冲突jar时，右击可以进行处理\"></a>3.当出现冲突jar时，右击可以进行处理</h3><p>当然，处理jar包，还是需要进行评估下，是否会对系统的功能有影响，不能盲目的一顿操作。</p>\n"},{"title":"lambda-自定义函数接口","date":"2020-11-12T09:12:49.000Z","_content":"\n\n\n## 自定义函数式编程\n\n编写一个只有一个抽象方法的接口类，使用 @FunctionalInterface 修饰。@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范\n\n``` java\n@FunctionalInterface\npublic interface AddInterface {\n    int add(Integer a, Integer b);\n}\n```\n\n那么我们就可以在代码中直接使用了\n\n```java\n    AddInterface addInterface = (a,b) -> a-b;\n```\n\n\n\n## lambda表达式的使用\n\n### 1.无参\n\n```java\nThread thread = new Thread(() -> System.out.println(\"执行线程方法\"));\n```\n\n### 2.有参数\n\n上面自定义的接口就是有两个参数的接口\n\n```java\n   AddInterface addInterface = (a,b) -> a-b;\n```\n\n\n### lambda表达式\n\n使用lambda表达式时，java在进行编译的使用，不会像匿名内部类那样生成新的类文件，而是作为主类的私用方法","source":"_posts/日常/lambda-自定义函数接口.md","raw":"---\ntitle: lambda-自定义函数接口\ndate: 2020-11-12 17:12:49\ncategories: \n    - 日常\ntags: \n    - lambda\n---\n\n\n\n## 自定义函数式编程\n\n编写一个只有一个抽象方法的接口类，使用 @FunctionalInterface 修饰。@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范\n\n``` java\n@FunctionalInterface\npublic interface AddInterface {\n    int add(Integer a, Integer b);\n}\n```\n\n那么我们就可以在代码中直接使用了\n\n```java\n    AddInterface addInterface = (a,b) -> a-b;\n```\n\n\n\n## lambda表达式的使用\n\n### 1.无参\n\n```java\nThread thread = new Thread(() -> System.out.println(\"执行线程方法\"));\n```\n\n### 2.有参数\n\n上面自定义的接口就是有两个参数的接口\n\n```java\n   AddInterface addInterface = (a,b) -> a-b;\n```\n\n\n### lambda表达式\n\n使用lambda表达式时，java在进行编译的使用，不会像匿名内部类那样生成新的类文件，而是作为主类的私用方法","slug":"日常/lambda-自定义函数接口","published":1,"updated":"2020-12-03T05:35:38.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0m001854vi6f8lbcab","content":"<h2 id=\"自定义函数式编程\"><a href=\"#自定义函数式编程\" class=\"headerlink\" title=\"自定义函数式编程\"></a>自定义函数式编程</h2><p>编写一个只有一个抽象方法的接口类，使用 @FunctionalInterface 修饰。@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AddInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(Integer a, Integer b)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们就可以在代码中直接使用了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AddInterface addInterface = (a,b) -&gt; a-b;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"lambda表达式的使用\"><a href=\"#lambda表达式的使用\" class=\"headerlink\" title=\"lambda表达式的使用\"></a>lambda表达式的使用</h2><h3 id=\"1-无参\"><a href=\"#1-无参\" class=\"headerlink\" title=\"1.无参\"></a>1.无参</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; System.out.println(<span class=\"string\">&quot;执行线程方法&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-有参数\"><a href=\"#2-有参数\" class=\"headerlink\" title=\"2.有参数\"></a>2.有参数</h3><p>上面自定义的接口就是有两个参数的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AddInterface addInterface = (a,b) -&gt; a-b;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h3><p>使用lambda表达式时，java在进行编译的使用，不会像匿名内部类那样生成新的类文件，而是作为主类的私用方法</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"自定义函数式编程\"><a href=\"#自定义函数式编程\" class=\"headerlink\" title=\"自定义函数式编程\"></a>自定义函数式编程</h2><p>编写一个只有一个抽象方法的接口类，使用 @FunctionalInterface 修饰。@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AddInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(Integer a, Integer b)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们就可以在代码中直接使用了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AddInterface addInterface = (a,b) -&gt; a-b;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"lambda表达式的使用\"><a href=\"#lambda表达式的使用\" class=\"headerlink\" title=\"lambda表达式的使用\"></a>lambda表达式的使用</h2><h3 id=\"1-无参\"><a href=\"#1-无参\" class=\"headerlink\" title=\"1.无参\"></a>1.无参</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; System.out.println(<span class=\"string\">&quot;执行线程方法&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-有参数\"><a href=\"#2-有参数\" class=\"headerlink\" title=\"2.有参数\"></a>2.有参数</h3><p>上面自定义的接口就是有两个参数的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AddInterface addInterface = (a,b) -&gt; a-b;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h3><p>使用lambda表达式时，java在进行编译的使用，不会像匿名内部类那样生成新的类文件，而是作为主类的私用方法</p>\n"},{"title":"JVM学习笔记-垃圾回收机制","date":"2019-05-24T08:06:15.000Z","_content":"\n&#160; &#160; &#160; &#160;我们来学习一下jvm中比较重要的一块内容-GC。那么我们学习了GC与内存分配，能做什么呢？ 当我们需要排除各种内存溢出、内存泄漏等问题时，当垃圾收集成为系统大道更高并发的瓶颈时，我们就需要对GC实施必要的监控和调节。\n\n\n### 哪些对象可变回收\n&#160; &#160; &#160; &#160;垃圾回收器会定期回收堆内存中不在被使用的对象，通常判断对象是否需要被回收，有两种方式，引用计数法和可达性分析\n\n#### 引用计数法\n\n&#160; &#160; &#160; &#160;每个对象都有一个引用计数器，每当有一个地方引用该对象，引用计数就会+1，如果引用失效就会-1，当引用计数值为0的时候，这个对象就不在被使用。这种实现方式简单，判断效率高。但是他<font color='red'>存在一个问题，就是如果对象相互循环引用，那么这些对象就不能被回收</font>。java虚拟机没有采用这种实现方式。\n\n```\npublic class TestGC{\n\n    public Object instance = null;\n    private byte[] bigSize = new byte[1024*1024*2];\n\n    public static void main(String[] args){\n\n        // o1 和 o2 相互引用\n        TestGC o1 = new TestGC();\n        TestGC o2 = new TestGC();\n        o1.instance = o2;\n        o2.instance = o1;\n\n        //此时两个对象都不能再被访问，但是他们相互引用对方，引用计数值都不是0\n        o1 = null;\n        o2 = null;\n        //假设在这里发生GC，他们并不会被回收\n        System.gc();\n    }\n\n}\n\n```\n\n#### 可达性分析\n\n&#160; &#160; &#160; &#160;从GC Roots开始向下搜索，搜索走过的路径称为引用链，当无法从GC Roots通过引用链到达某个对象，那么这个对象就是不可达，需要被回收。\n\njava中，以下可作为GC Roots对象：\n\n- 虚拟机栈（栈帧中国的本地变量表）中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI引用的对象\n\n![GC Roots](./GCRoots.png)\n\n### 引用\n\n\njdk1.2之后，java对引用进行了扩展，将引用分为强引用，软引用，弱引用和虚引用。四种引用强度一次逐渐减弱。\n\n- 强引用\n\n强引用在java代码中是最常见的， 当我们new一个对象的时候，就是一个强引用。只要强引用存在，垃圾回收机制就不会回收对象。\n\n- 软引用\n\n软引用是描述一些有用但是非必须的对象。系统在发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果系统存在足够的内存，这些对象不会被回收，如果内存不足，则会回收这些对象。java提供SoftReference类实现软引用。\n\n- 弱引用\n\n弱引用描述非必需对象的。弱引用的对象只能生存到下一次垃圾回收之前。当开始垃圾回收时，不过内存是否足够都会回收弱引用的对象。java提供WeakReference类来实现弱引用。\n\n- 虚引用\n\n一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用主要是为了该对象在垃圾收集器回收会收到一个系统通知。java提供PhantomReference类来实现。\n\n","source":"_posts/jvm/java-jvm-gc.md","raw":"---\ntitle: JVM学习笔记-垃圾回收机制\ndate: 2019-05-24 16:06:15\ncategories: \n    - JAVA_JVM\ntags: \n    - JVM\n---\n\n&#160; &#160; &#160; &#160;我们来学习一下jvm中比较重要的一块内容-GC。那么我们学习了GC与内存分配，能做什么呢？ 当我们需要排除各种内存溢出、内存泄漏等问题时，当垃圾收集成为系统大道更高并发的瓶颈时，我们就需要对GC实施必要的监控和调节。\n\n\n### 哪些对象可变回收\n&#160; &#160; &#160; &#160;垃圾回收器会定期回收堆内存中不在被使用的对象，通常判断对象是否需要被回收，有两种方式，引用计数法和可达性分析\n\n#### 引用计数法\n\n&#160; &#160; &#160; &#160;每个对象都有一个引用计数器，每当有一个地方引用该对象，引用计数就会+1，如果引用失效就会-1，当引用计数值为0的时候，这个对象就不在被使用。这种实现方式简单，判断效率高。但是他<font color='red'>存在一个问题，就是如果对象相互循环引用，那么这些对象就不能被回收</font>。java虚拟机没有采用这种实现方式。\n\n```\npublic class TestGC{\n\n    public Object instance = null;\n    private byte[] bigSize = new byte[1024*1024*2];\n\n    public static void main(String[] args){\n\n        // o1 和 o2 相互引用\n        TestGC o1 = new TestGC();\n        TestGC o2 = new TestGC();\n        o1.instance = o2;\n        o2.instance = o1;\n\n        //此时两个对象都不能再被访问，但是他们相互引用对方，引用计数值都不是0\n        o1 = null;\n        o2 = null;\n        //假设在这里发生GC，他们并不会被回收\n        System.gc();\n    }\n\n}\n\n```\n\n#### 可达性分析\n\n&#160; &#160; &#160; &#160;从GC Roots开始向下搜索，搜索走过的路径称为引用链，当无法从GC Roots通过引用链到达某个对象，那么这个对象就是不可达，需要被回收。\n\njava中，以下可作为GC Roots对象：\n\n- 虚拟机栈（栈帧中国的本地变量表）中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI引用的对象\n\n![GC Roots](./GCRoots.png)\n\n### 引用\n\n\njdk1.2之后，java对引用进行了扩展，将引用分为强引用，软引用，弱引用和虚引用。四种引用强度一次逐渐减弱。\n\n- 强引用\n\n强引用在java代码中是最常见的， 当我们new一个对象的时候，就是一个强引用。只要强引用存在，垃圾回收机制就不会回收对象。\n\n- 软引用\n\n软引用是描述一些有用但是非必须的对象。系统在发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果系统存在足够的内存，这些对象不会被回收，如果内存不足，则会回收这些对象。java提供SoftReference类实现软引用。\n\n- 弱引用\n\n弱引用描述非必需对象的。弱引用的对象只能生存到下一次垃圾回收之前。当开始垃圾回收时，不过内存是否足够都会回收弱引用的对象。java提供WeakReference类来实现弱引用。\n\n- 虚引用\n\n一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用主要是为了该对象在垃圾收集器回收会收到一个系统通知。java提供PhantomReference类来实现。\n\n","slug":"jvm/java-jvm-gc","published":1,"updated":"2020-11-03T16:13:26.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0n001a54vib8zshsv8","content":"<p>&#160; &#160; &#160; &#160;我们来学习一下jvm中比较重要的一块内容-GC。那么我们学习了GC与内存分配，能做什么呢？ 当我们需要排除各种内存溢出、内存泄漏等问题时，当垃圾收集成为系统大道更高并发的瓶颈时，我们就需要对GC实施必要的监控和调节。</p>\n<h3 id=\"哪些对象可变回收\"><a href=\"#哪些对象可变回收\" class=\"headerlink\" title=\"哪些对象可变回收\"></a>哪些对象可变回收</h3><p>&#160; &#160; &#160; &#160;垃圾回收器会定期回收堆内存中不在被使用的对象，通常判断对象是否需要被回收，有两种方式，引用计数法和可达性分析</p>\n<h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>&#160; &#160; &#160; &#160;每个对象都有一个引用计数器，每当有一个地方引用该对象，引用计数就会+1，如果引用失效就会-1，当引用计数值为0的时候，这个对象就不在被使用。这种实现方式简单，判断效率高。但是他<font color='red'>存在一个问题，就是如果对象相互循环引用，那么这些对象就不能被回收</font>。java虚拟机没有采用这种实现方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestGC&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object instance &#x3D; null;</span><br><span class=\"line\">    private byte[] bigSize &#x3D; new byte[1024*1024*2];</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; o1 和 o2 相互引用</span><br><span class=\"line\">        TestGC o1 &#x3D; new TestGC();</span><br><span class=\"line\">        TestGC o2 &#x3D; new TestGC();</span><br><span class=\"line\">        o1.instance &#x3D; o2;</span><br><span class=\"line\">        o2.instance &#x3D; o1;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;此时两个对象都不能再被访问，但是他们相互引用对方，引用计数值都不是0</span><br><span class=\"line\">        o1 &#x3D; null;</span><br><span class=\"line\">        o2 &#x3D; null;</span><br><span class=\"line\">        &#x2F;&#x2F;假设在这里发生GC，他们并不会被回收</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可达性分析\"><a href=\"#可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a>可达性分析</h4><p>&#160; &#160; &#160; &#160;从GC Roots开始向下搜索，搜索走过的路径称为引用链，当无法从GC Roots通过引用链到达某个对象，那么这个对象就是不可达，需要被回收。</p>\n<p>java中，以下可作为GC Roots对象：</p>\n<ul>\n<li>虚拟机栈（栈帧中国的本地变量表）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI引用的对象</li>\n</ul>\n<p><img src=\"./GCRoots.png\" alt=\"GC Roots\"></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>jdk1.2之后，java对引用进行了扩展，将引用分为强引用，软引用，弱引用和虚引用。四种引用强度一次逐渐减弱。</p>\n<ul>\n<li>强引用</li>\n</ul>\n<p>强引用在java代码中是最常见的， 当我们new一个对象的时候，就是一个强引用。只要强引用存在，垃圾回收机制就不会回收对象。</p>\n<ul>\n<li>软引用</li>\n</ul>\n<p>软引用是描述一些有用但是非必须的对象。系统在发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果系统存在足够的内存，这些对象不会被回收，如果内存不足，则会回收这些对象。java提供SoftReference类实现软引用。</p>\n<ul>\n<li>弱引用</li>\n</ul>\n<p>弱引用描述非必需对象的。弱引用的对象只能生存到下一次垃圾回收之前。当开始垃圾回收时，不过内存是否足够都会回收弱引用的对象。java提供WeakReference类来实现弱引用。</p>\n<ul>\n<li>虚引用</li>\n</ul>\n<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用主要是为了该对象在垃圾收集器回收会收到一个系统通知。java提供PhantomReference类来实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&#160; &#160; &#160; &#160;我们来学习一下jvm中比较重要的一块内容-GC。那么我们学习了GC与内存分配，能做什么呢？ 当我们需要排除各种内存溢出、内存泄漏等问题时，当垃圾收集成为系统大道更高并发的瓶颈时，我们就需要对GC实施必要的监控和调节。</p>\n<h3 id=\"哪些对象可变回收\"><a href=\"#哪些对象可变回收\" class=\"headerlink\" title=\"哪些对象可变回收\"></a>哪些对象可变回收</h3><p>&#160; &#160; &#160; &#160;垃圾回收器会定期回收堆内存中不在被使用的对象，通常判断对象是否需要被回收，有两种方式，引用计数法和可达性分析</p>\n<h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>&#160; &#160; &#160; &#160;每个对象都有一个引用计数器，每当有一个地方引用该对象，引用计数就会+1，如果引用失效就会-1，当引用计数值为0的时候，这个对象就不在被使用。这种实现方式简单，判断效率高。但是他<font color='red'>存在一个问题，就是如果对象相互循环引用，那么这些对象就不能被回收</font>。java虚拟机没有采用这种实现方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestGC&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Object instance &#x3D; null;</span><br><span class=\"line\">    private byte[] bigSize &#x3D; new byte[1024*1024*2];</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; o1 和 o2 相互引用</span><br><span class=\"line\">        TestGC o1 &#x3D; new TestGC();</span><br><span class=\"line\">        TestGC o2 &#x3D; new TestGC();</span><br><span class=\"line\">        o1.instance &#x3D; o2;</span><br><span class=\"line\">        o2.instance &#x3D; o1;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;此时两个对象都不能再被访问，但是他们相互引用对方，引用计数值都不是0</span><br><span class=\"line\">        o1 &#x3D; null;</span><br><span class=\"line\">        o2 &#x3D; null;</span><br><span class=\"line\">        &#x2F;&#x2F;假设在这里发生GC，他们并不会被回收</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可达性分析\"><a href=\"#可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a>可达性分析</h4><p>&#160; &#160; &#160; &#160;从GC Roots开始向下搜索，搜索走过的路径称为引用链，当无法从GC Roots通过引用链到达某个对象，那么这个对象就是不可达，需要被回收。</p>\n<p>java中，以下可作为GC Roots对象：</p>\n<ul>\n<li>虚拟机栈（栈帧中国的本地变量表）中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI引用的对象</li>\n</ul>\n<p><img src=\"./GCRoots.png\" alt=\"GC Roots\"></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>jdk1.2之后，java对引用进行了扩展，将引用分为强引用，软引用，弱引用和虚引用。四种引用强度一次逐渐减弱。</p>\n<ul>\n<li>强引用</li>\n</ul>\n<p>强引用在java代码中是最常见的， 当我们new一个对象的时候，就是一个强引用。只要强引用存在，垃圾回收机制就不会回收对象。</p>\n<ul>\n<li>软引用</li>\n</ul>\n<p>软引用是描述一些有用但是非必须的对象。系统在发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果系统存在足够的内存，这些对象不会被回收，如果内存不足，则会回收这些对象。java提供SoftReference类实现软引用。</p>\n<ul>\n<li>弱引用</li>\n</ul>\n<p>弱引用描述非必需对象的。弱引用的对象只能生存到下一次垃圾回收之前。当开始垃圾回收时，不过内存是否足够都会回收弱引用的对象。java提供WeakReference类来实现弱引用。</p>\n<ul>\n<li>虚引用</li>\n</ul>\n<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用主要是为了该对象在垃圾收集器回收会收到一个系统通知。java提供PhantomReference类来实现。</p>\n"},{"title":"面试(20-11-4)","date":"2020-11-22T15:18:16.000Z","_content":"# 1.自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者\n\n一个管理者，先要知道管理者的定义：带领并发动你的团队，而不是自己把事情干了\n\n管理者需要服众，不要远离业务，保持专业能力，成为下属的榜样，可以带着团队干事。\n\n学会授权，培养能力强的人，让他分担你的工作。同时要规范流程，授权下属去做，定期汇报工作的成果。\n\n同时，自己也要积极向上汇报工作进度，表现自己的责任感。获得更多的信任。","source":"_posts/日常/得到-20-11-4.md","raw":"---\ntitle: 面试(20-11-4)\ndate: 2020-11-22 23:18:16\ncategories: \n    - 得到\ntags: \n    - 读书笔记\n---\n# 1.自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者\n\n一个管理者，先要知道管理者的定义：带领并发动你的团队，而不是自己把事情干了\n\n管理者需要服众，不要远离业务，保持专业能力，成为下属的榜样，可以带着团队干事。\n\n学会授权，培养能力强的人，让他分担你的工作。同时要规范流程，授权下属去做，定期汇报工作的成果。\n\n同时，自己也要积极向上汇报工作进度，表现自己的责任感。获得更多的信任。","slug":"日常/得到-20-11-4","published":1,"updated":"2020-11-26T03:21:43.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0o001e54viag45g10k","content":"<h1 id=\"1-自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者\"><a href=\"#1-自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者\" class=\"headerlink\" title=\"1.自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者\"></a>1.自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者</h1><p>一个管理者，先要知道管理者的定义：带领并发动你的团队，而不是自己把事情干了</p>\n<p>管理者需要服众，不要远离业务，保持专业能力，成为下属的榜样，可以带着团队干事。</p>\n<p>学会授权，培养能力强的人，让他分担你的工作。同时要规范流程，授权下属去做，定期汇报工作的成果。</p>\n<p>同时，自己也要积极向上汇报工作进度，表现自己的责任感。获得更多的信任。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者\"><a href=\"#1-自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者\" class=\"headerlink\" title=\"1.自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者\"></a>1.自己已经升为管理岗位，但是还是在做着业务，想知道如何成为一个管理者</h1><p>一个管理者，先要知道管理者的定义：带领并发动你的团队，而不是自己把事情干了</p>\n<p>管理者需要服众，不要远离业务，保持专业能力，成为下属的榜样，可以带着团队干事。</p>\n<p>学会授权，培养能力强的人，让他分担你的工作。同时要规范流程，授权下属去做，定期汇报工作的成果。</p>\n<p>同时，自己也要积极向上汇报工作进度，表现自己的责任感。获得更多的信任。</p>\n"},{"title":"markdown使用技巧","date":"2020-11-15T13:50:32.000Z","_content":"\n- 给文字添加颜色（使用html标签）\n```\n<font color = 'red'> content <font>\n```\n<font color = 'red'> content <font>","source":"_posts/日常/markdown使用技巧.md","raw":"---\ntitle: markdown使用技巧\ndate: 2020-11-15 21:50:32\ncategories: \n    - 日常\n    - 技巧\ntags: \n    - markdown\n    - 技巧\n---\n\n- 给文字添加颜色（使用html标签）\n```\n<font color = 'red'> content <font>\n```\n<font color = 'red'> content <font>","slug":"日常/markdown使用技巧","published":1,"updated":"2020-11-26T03:21:43.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0p001g54vi9hzmc9bj","content":"<ul>\n<li>给文字添加颜色（使用html标签）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font color &#x3D; &#39;red&#39;&gt; content &lt;font&gt;</span><br></pre></td></tr></table></figure>\n<font color = 'red'> content <font></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>给文字添加颜色（使用html标签）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;font color &#x3D; &#39;red&#39;&gt; content &lt;font&gt;</span><br></pre></td></tr></table></figure>\n<font color = 'red'> content <font></li>\n</ul>\n"},{"title":"自我提升(20-11-3)","date":"2020-11-15T11:40:25.000Z","_content":"\n从今天开始，每天从得到上学习，并且记录学习的收货，可摘抄，感想，收获等，不管记录的是多是少，都要每天更新。断更时，记录断更的原因。\n\n记录的维度暂时以周为单位，一周一个主题。写博客的目的还是为了个人提升，所以本周以提升个人能力为主题。\n\n<!--more-->\n\n问题：\n在写的过程中发现，自己太啰嗦了，没有逻辑\n\n规定：表达有逻辑，语言精炼\n\n自我提升\n===\n\n\n# 1.如何选择适合自己的书 \n\n想去读一本书，却不知道从那本书开始，又或者读了很多的书，却毫无长进。那么我们如何去解决呢。《精进》的作者采铜老师在得到锦囊中分享了自己的心得。\n\n看书需要先从选书开始，直接碰到适合自己的书很难，还是需要我们自己主动去寻找书籍。\n\n1. **筛选**：我们可以去筛选自己想要读的书，书籍排行榜，大V的推荐等。这一步不是为了盲目的跟从，主要的目的还是为了让自己知道，哦，原来还有这样一本书。提高自己的渠道的一种方法。\n2. **试读**：选取一小部分去读，看看写的内容，自己是否感兴趣\n3. **泛读**：从头到尾读一遍，了解结构，观点。分析对你有什么启发，形成对这本书的基本认识。\n4. **精读**：想要透彻体悟书的思想，形成深层次的共鸣。就需要进行精读，这样你，你的思维，学习能力才会提升。\n\n在我看来读书的目的是增加自己见闻的一种方式。经验的传播最好的方式，是面对面的进行。书弥补了时间，空间等问题带来的阻碍。读书缺少了引导的粒度，需要读者自行去思考，由面到点，由点到线，再到面。付出实践方得成长。\n\n**<font color=\"red\" >如何获取适合自己的东西</font>**\n\n- 运气\n- 接触，尝试，经历，机会\n\n\n# 2.如何搭建自己的知识体系\n\n在我看来知识体系，就如同三维的蜘蛛网，点与点相连，每个知识点是知识点1的延伸，又是知识点2的基础，轻盈而又有黏性。知识体系的搭建重要的数量与质量，脑袋空空，一知半解何谈体系。\n\n搭建体系从基础的概念开始，基础打牢才好扩展。学习知识，了解根源，背景，应用才是搭建体系的价值所在。搭建好基础后，由问题为引导，穿针引线，将知识串联起来，逐渐深入，深入之后进行发散，使之变得丰富和多元化，这样知识体系才会慢慢扩展起来。\n\n知识深入才能成为高手，当可以独当一面的时候，再去拓展知识的广度，需要注意的是，广度的增加是需要与你深入的领域相关的，而不是天马行空去涉猎。\n\n\n# 3.如何建立自己的人脉\n\n回答问题之前，先普两个概念：人际关系网中的强关系和弱关系。  \n强关系和托关系理论是美国社会学家格兰诺维特提出的，\n\n**强关系**:指个人的社会网络同性质较强，关系紧密，有很强的情感支撑，比如亲戚关系。  \n**弱关系**:特点是个人的社会网络异质性较强关系不紧密没有太多的感情维系就是我们常说的泛泛之交。\n\n刚到一个城市时，同时通过强关系建立起初级网络，比如亲戚，老乡，老同学等等。之后通过职业，兴趣等建立次级网络。通过通过弱关系进行维持。与强关系相比，弱关系可以让你接触到更多的信息。\n\n在日常生活中，不要过度依赖维持初级网络，强关系本来就有很大的黏性，过度维持会阻碍人脉的建立。\n\n多结交网络中受欢迎的人，他们可以帮你带来更多的人脉，同时要提升自己的重要程度，让自己成为可以牵线搭桥的人。\n\n\n# 4.被他人夸奖我们应该如何回应。\n\n一般情况下，夸奖别人是客套话，从而打开话题，所以不需要太当真。被夸奖后可以感谢对方，同时可以将话题引到对方身上，比如夸赞对方的衣着，或者聊聊对方的孩子或者最近发生的事，比如出去旅游了，咨询下旅游地的特色等等。\n\n\n# 5.如何经营自己的朋友圈\n\n朋友圈是一张名片，经营的好可以提升个人品牌，用不好只能黑房间。先说说我自己的朋友圈。很少发动态，一张图片证明我没有拉黑你，哈哈。对应朋友的动态，有些朋友定期更新，配图和文字看着舒服，这些人，不由自主的会有好感。当然朋友圈中也有被拉黑的人，不乏朋友，亲戚，因为更新的过于频繁，内容乏味，枯燥，无意义的负面情绪，除非我对你有好感，不然不好意思拉黑。\n\n那如何去更新自己的朋友圈呢，一个不发朋友圈的来说说自己的观点，你敢信吗？\n\n首先为什么需要去更新朋友圈。更新朋友圈对看的人来说，可以对你有所了解，减少隔阂，及时很少联系，也能感觉对你很熟悉。它就是你的社会履历，是你对外的工作人格。经营好了可以提升你的个人品牌，获得更多的资源。\n\n如何去做呢：\n\n- 明确定位。先想想自己能够成为什么样的人，有个基本的人设。\n- 分析优势。找到自己擅长的事情，明确更新的内容方向\n- 主要更新时间。选择他人适合阅读的时间，大半夜发朋友圈，给鬼看呢。\n- 维护形象。朋友圈要展现正面，积极的一面，我本身就很烦躁的，还要看你瞎抱怨呢。\n- 不能过于平凡，定期更新有趣的内容。都是日常，不好意思我不想了解。\n- 主要目的。个原因就是找到沟通的诱因，回复评论时，主要可以延续话题。\n\n最后一点，如何去关注别人的朋友圈。展现友好的一面时，点赞，表示我在关注你，我同意的态度。注意敏感话题，可以私聊单不可直接评论。\n\n\n# 6.如何添加了大牛的微信，不被拉黑\n\n与人打交道，重要的是学会换位思考\n\n- 态度要不卑不亢，唯唯诺诺会让人瞧不起\n- 让对方知道你的价值所在，并且可被对方用到\n- 找到相对平等的地方，在加微信，让对方对你有些了解，消除隔阂感\n- 多认识中间人，通过中间人引荐，更容易成功\n\n\n# 7.部门会议上，怕出错，又想被注意到，该怎么办\n\n这种担心在日常生活中，其实和常见。我认为主要的原因：  \n1：不自信，自己给自己的心里加压  \n2：没有过硬的专业知识去支撑着你  \n\n从根源出发，看看有什么解决的方案\n \n尽量与参会的人员混熟，减少陌生感  \n从他人角度去思考一下，一般同事间的包容还是挺好的，同时很少人会关注你，内心戏不要太多  \n加强自己的专业知识，可以增强信心  \n主动承担责任，跟踪进度，给自己目标，每次会议发言一次。\n\n\n\n\n\n\n\n\n\n\n<br/>\n<br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/日常/得到-20-11.md","raw":"---\ntitle: 自我提升(20-11-3)\ndate: 2020-11-15 19:40:25\ncategories: \n    - 得到\ntags: \n    - 读书笔记\n---\n\n从今天开始，每天从得到上学习，并且记录学习的收货，可摘抄，感想，收获等，不管记录的是多是少，都要每天更新。断更时，记录断更的原因。\n\n记录的维度暂时以周为单位，一周一个主题。写博客的目的还是为了个人提升，所以本周以提升个人能力为主题。\n\n<!--more-->\n\n问题：\n在写的过程中发现，自己太啰嗦了，没有逻辑\n\n规定：表达有逻辑，语言精炼\n\n自我提升\n===\n\n\n# 1.如何选择适合自己的书 \n\n想去读一本书，却不知道从那本书开始，又或者读了很多的书，却毫无长进。那么我们如何去解决呢。《精进》的作者采铜老师在得到锦囊中分享了自己的心得。\n\n看书需要先从选书开始，直接碰到适合自己的书很难，还是需要我们自己主动去寻找书籍。\n\n1. **筛选**：我们可以去筛选自己想要读的书，书籍排行榜，大V的推荐等。这一步不是为了盲目的跟从，主要的目的还是为了让自己知道，哦，原来还有这样一本书。提高自己的渠道的一种方法。\n2. **试读**：选取一小部分去读，看看写的内容，自己是否感兴趣\n3. **泛读**：从头到尾读一遍，了解结构，观点。分析对你有什么启发，形成对这本书的基本认识。\n4. **精读**：想要透彻体悟书的思想，形成深层次的共鸣。就需要进行精读，这样你，你的思维，学习能力才会提升。\n\n在我看来读书的目的是增加自己见闻的一种方式。经验的传播最好的方式，是面对面的进行。书弥补了时间，空间等问题带来的阻碍。读书缺少了引导的粒度，需要读者自行去思考，由面到点，由点到线，再到面。付出实践方得成长。\n\n**<font color=\"red\" >如何获取适合自己的东西</font>**\n\n- 运气\n- 接触，尝试，经历，机会\n\n\n# 2.如何搭建自己的知识体系\n\n在我看来知识体系，就如同三维的蜘蛛网，点与点相连，每个知识点是知识点1的延伸，又是知识点2的基础，轻盈而又有黏性。知识体系的搭建重要的数量与质量，脑袋空空，一知半解何谈体系。\n\n搭建体系从基础的概念开始，基础打牢才好扩展。学习知识，了解根源，背景，应用才是搭建体系的价值所在。搭建好基础后，由问题为引导，穿针引线，将知识串联起来，逐渐深入，深入之后进行发散，使之变得丰富和多元化，这样知识体系才会慢慢扩展起来。\n\n知识深入才能成为高手，当可以独当一面的时候，再去拓展知识的广度，需要注意的是，广度的增加是需要与你深入的领域相关的，而不是天马行空去涉猎。\n\n\n# 3.如何建立自己的人脉\n\n回答问题之前，先普两个概念：人际关系网中的强关系和弱关系。  \n强关系和托关系理论是美国社会学家格兰诺维特提出的，\n\n**强关系**:指个人的社会网络同性质较强，关系紧密，有很强的情感支撑，比如亲戚关系。  \n**弱关系**:特点是个人的社会网络异质性较强关系不紧密没有太多的感情维系就是我们常说的泛泛之交。\n\n刚到一个城市时，同时通过强关系建立起初级网络，比如亲戚，老乡，老同学等等。之后通过职业，兴趣等建立次级网络。通过通过弱关系进行维持。与强关系相比，弱关系可以让你接触到更多的信息。\n\n在日常生活中，不要过度依赖维持初级网络，强关系本来就有很大的黏性，过度维持会阻碍人脉的建立。\n\n多结交网络中受欢迎的人，他们可以帮你带来更多的人脉，同时要提升自己的重要程度，让自己成为可以牵线搭桥的人。\n\n\n# 4.被他人夸奖我们应该如何回应。\n\n一般情况下，夸奖别人是客套话，从而打开话题，所以不需要太当真。被夸奖后可以感谢对方，同时可以将话题引到对方身上，比如夸赞对方的衣着，或者聊聊对方的孩子或者最近发生的事，比如出去旅游了，咨询下旅游地的特色等等。\n\n\n# 5.如何经营自己的朋友圈\n\n朋友圈是一张名片，经营的好可以提升个人品牌，用不好只能黑房间。先说说我自己的朋友圈。很少发动态，一张图片证明我没有拉黑你，哈哈。对应朋友的动态，有些朋友定期更新，配图和文字看着舒服，这些人，不由自主的会有好感。当然朋友圈中也有被拉黑的人，不乏朋友，亲戚，因为更新的过于频繁，内容乏味，枯燥，无意义的负面情绪，除非我对你有好感，不然不好意思拉黑。\n\n那如何去更新自己的朋友圈呢，一个不发朋友圈的来说说自己的观点，你敢信吗？\n\n首先为什么需要去更新朋友圈。更新朋友圈对看的人来说，可以对你有所了解，减少隔阂，及时很少联系，也能感觉对你很熟悉。它就是你的社会履历，是你对外的工作人格。经营好了可以提升你的个人品牌，获得更多的资源。\n\n如何去做呢：\n\n- 明确定位。先想想自己能够成为什么样的人，有个基本的人设。\n- 分析优势。找到自己擅长的事情，明确更新的内容方向\n- 主要更新时间。选择他人适合阅读的时间，大半夜发朋友圈，给鬼看呢。\n- 维护形象。朋友圈要展现正面，积极的一面，我本身就很烦躁的，还要看你瞎抱怨呢。\n- 不能过于平凡，定期更新有趣的内容。都是日常，不好意思我不想了解。\n- 主要目的。个原因就是找到沟通的诱因，回复评论时，主要可以延续话题。\n\n最后一点，如何去关注别人的朋友圈。展现友好的一面时，点赞，表示我在关注你，我同意的态度。注意敏感话题，可以私聊单不可直接评论。\n\n\n# 6.如何添加了大牛的微信，不被拉黑\n\n与人打交道，重要的是学会换位思考\n\n- 态度要不卑不亢，唯唯诺诺会让人瞧不起\n- 让对方知道你的价值所在，并且可被对方用到\n- 找到相对平等的地方，在加微信，让对方对你有些了解，消除隔阂感\n- 多认识中间人，通过中间人引荐，更容易成功\n\n\n# 7.部门会议上，怕出错，又想被注意到，该怎么办\n\n这种担心在日常生活中，其实和常见。我认为主要的原因：  \n1：不自信，自己给自己的心里加压  \n2：没有过硬的专业知识去支撑着你  \n\n从根源出发，看看有什么解决的方案\n \n尽量与参会的人员混熟，减少陌生感  \n从他人角度去思考一下，一般同事间的包容还是挺好的，同时很少人会关注你，内心戏不要太多  \n加强自己的专业知识，可以增强信心  \n主动承担责任，跟踪进度，给自己目标，每次会议发言一次。\n\n\n\n\n\n\n\n\n\n\n<br/>\n<br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"日常/得到-20-11","published":1,"updated":"2020-11-26T03:21:43.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0r001l54vi4plreys6","content":"<p>从今天开始，每天从得到上学习，并且记录学习的收货，可摘抄，感想，收获等，不管记录的是多是少，都要每天更新。断更时，记录断更的原因。</p>\n<p>记录的维度暂时以周为单位，一周一个主题。写博客的目的还是为了个人提升，所以本周以提升个人能力为主题。</p>\n<a id=\"more\"></a>\n\n<p>问题：<br>在写的过程中发现，自己太啰嗦了，没有逻辑</p>\n<p>规定：表达有逻辑，语言精炼</p>\n<h1 id=\"自我提升\"><a href=\"#自我提升\" class=\"headerlink\" title=\"自我提升\"></a>自我提升</h1><h1 id=\"1-如何选择适合自己的书\"><a href=\"#1-如何选择适合自己的书\" class=\"headerlink\" title=\"1.如何选择适合自己的书\"></a>1.如何选择适合自己的书</h1><p>想去读一本书，却不知道从那本书开始，又或者读了很多的书，却毫无长进。那么我们如何去解决呢。《精进》的作者采铜老师在得到锦囊中分享了自己的心得。</p>\n<p>看书需要先从选书开始，直接碰到适合自己的书很难，还是需要我们自己主动去寻找书籍。</p>\n<ol>\n<li><strong>筛选</strong>：我们可以去筛选自己想要读的书，书籍排行榜，大V的推荐等。这一步不是为了盲目的跟从，主要的目的还是为了让自己知道，哦，原来还有这样一本书。提高自己的渠道的一种方法。</li>\n<li><strong>试读</strong>：选取一小部分去读，看看写的内容，自己是否感兴趣</li>\n<li><strong>泛读</strong>：从头到尾读一遍，了解结构，观点。分析对你有什么启发，形成对这本书的基本认识。</li>\n<li><strong>精读</strong>：想要透彻体悟书的思想，形成深层次的共鸣。就需要进行精读，这样你，你的思维，学习能力才会提升。</li>\n</ol>\n<p>在我看来读书的目的是增加自己见闻的一种方式。经验的传播最好的方式，是面对面的进行。书弥补了时间，空间等问题带来的阻碍。读书缺少了引导的粒度，需要读者自行去思考，由面到点，由点到线，再到面。付出实践方得成长。</p>\n<p><strong><font color=\"red\" >如何获取适合自己的东西</font></strong></p>\n<ul>\n<li>运气</li>\n<li>接触，尝试，经历，机会</li>\n</ul>\n<h1 id=\"2-如何搭建自己的知识体系\"><a href=\"#2-如何搭建自己的知识体系\" class=\"headerlink\" title=\"2.如何搭建自己的知识体系\"></a>2.如何搭建自己的知识体系</h1><p>在我看来知识体系，就如同三维的蜘蛛网，点与点相连，每个知识点是知识点1的延伸，又是知识点2的基础，轻盈而又有黏性。知识体系的搭建重要的数量与质量，脑袋空空，一知半解何谈体系。</p>\n<p>搭建体系从基础的概念开始，基础打牢才好扩展。学习知识，了解根源，背景，应用才是搭建体系的价值所在。搭建好基础后，由问题为引导，穿针引线，将知识串联起来，逐渐深入，深入之后进行发散，使之变得丰富和多元化，这样知识体系才会慢慢扩展起来。</p>\n<p>知识深入才能成为高手，当可以独当一面的时候，再去拓展知识的广度，需要注意的是，广度的增加是需要与你深入的领域相关的，而不是天马行空去涉猎。</p>\n<h1 id=\"3-如何建立自己的人脉\"><a href=\"#3-如何建立自己的人脉\" class=\"headerlink\" title=\"3.如何建立自己的人脉\"></a>3.如何建立自己的人脉</h1><p>回答问题之前，先普两个概念：人际关系网中的强关系和弱关系。<br>强关系和托关系理论是美国社会学家格兰诺维特提出的，</p>\n<p><strong>强关系</strong>:指个人的社会网络同性质较强，关系紧密，有很强的情感支撑，比如亲戚关系。<br><strong>弱关系</strong>:特点是个人的社会网络异质性较强关系不紧密没有太多的感情维系就是我们常说的泛泛之交。</p>\n<p>刚到一个城市时，同时通过强关系建立起初级网络，比如亲戚，老乡，老同学等等。之后通过职业，兴趣等建立次级网络。通过通过弱关系进行维持。与强关系相比，弱关系可以让你接触到更多的信息。</p>\n<p>在日常生活中，不要过度依赖维持初级网络，强关系本来就有很大的黏性，过度维持会阻碍人脉的建立。</p>\n<p>多结交网络中受欢迎的人，他们可以帮你带来更多的人脉，同时要提升自己的重要程度，让自己成为可以牵线搭桥的人。</p>\n<h1 id=\"4-被他人夸奖我们应该如何回应。\"><a href=\"#4-被他人夸奖我们应该如何回应。\" class=\"headerlink\" title=\"4.被他人夸奖我们应该如何回应。\"></a>4.被他人夸奖我们应该如何回应。</h1><p>一般情况下，夸奖别人是客套话，从而打开话题，所以不需要太当真。被夸奖后可以感谢对方，同时可以将话题引到对方身上，比如夸赞对方的衣着，或者聊聊对方的孩子或者最近发生的事，比如出去旅游了，咨询下旅游地的特色等等。</p>\n<h1 id=\"5-如何经营自己的朋友圈\"><a href=\"#5-如何经营自己的朋友圈\" class=\"headerlink\" title=\"5.如何经营自己的朋友圈\"></a>5.如何经营自己的朋友圈</h1><p>朋友圈是一张名片，经营的好可以提升个人品牌，用不好只能黑房间。先说说我自己的朋友圈。很少发动态，一张图片证明我没有拉黑你，哈哈。对应朋友的动态，有些朋友定期更新，配图和文字看着舒服，这些人，不由自主的会有好感。当然朋友圈中也有被拉黑的人，不乏朋友，亲戚，因为更新的过于频繁，内容乏味，枯燥，无意义的负面情绪，除非我对你有好感，不然不好意思拉黑。</p>\n<p>那如何去更新自己的朋友圈呢，一个不发朋友圈的来说说自己的观点，你敢信吗？</p>\n<p>首先为什么需要去更新朋友圈。更新朋友圈对看的人来说，可以对你有所了解，减少隔阂，及时很少联系，也能感觉对你很熟悉。它就是你的社会履历，是你对外的工作人格。经营好了可以提升你的个人品牌，获得更多的资源。</p>\n<p>如何去做呢：</p>\n<ul>\n<li>明确定位。先想想自己能够成为什么样的人，有个基本的人设。</li>\n<li>分析优势。找到自己擅长的事情，明确更新的内容方向</li>\n<li>主要更新时间。选择他人适合阅读的时间，大半夜发朋友圈，给鬼看呢。</li>\n<li>维护形象。朋友圈要展现正面，积极的一面，我本身就很烦躁的，还要看你瞎抱怨呢。</li>\n<li>不能过于平凡，定期更新有趣的内容。都是日常，不好意思我不想了解。</li>\n<li>主要目的。个原因就是找到沟通的诱因，回复评论时，主要可以延续话题。</li>\n</ul>\n<p>最后一点，如何去关注别人的朋友圈。展现友好的一面时，点赞，表示我在关注你，我同意的态度。注意敏感话题，可以私聊单不可直接评论。</p>\n<h1 id=\"6-如何添加了大牛的微信，不被拉黑\"><a href=\"#6-如何添加了大牛的微信，不被拉黑\" class=\"headerlink\" title=\"6.如何添加了大牛的微信，不被拉黑\"></a>6.如何添加了大牛的微信，不被拉黑</h1><p>与人打交道，重要的是学会换位思考</p>\n<ul>\n<li>态度要不卑不亢，唯唯诺诺会让人瞧不起</li>\n<li>让对方知道你的价值所在，并且可被对方用到</li>\n<li>找到相对平等的地方，在加微信，让对方对你有些了解，消除隔阂感</li>\n<li>多认识中间人，通过中间人引荐，更容易成功</li>\n</ul>\n<h1 id=\"7-部门会议上，怕出错，又想被注意到，该怎么办\"><a href=\"#7-部门会议上，怕出错，又想被注意到，该怎么办\" class=\"headerlink\" title=\"7.部门会议上，怕出错，又想被注意到，该怎么办\"></a>7.部门会议上，怕出错，又想被注意到，该怎么办</h1><p>这种担心在日常生活中，其实和常见。我认为主要的原因：<br>1：不自信，自己给自己的心里加压<br>2：没有过硬的专业知识去支撑着你  </p>\n<p>从根源出发，看看有什么解决的方案</p>\n<p>尽量与参会的人员混熟，减少陌生感<br>从他人角度去思考一下，一般同事间的包容还是挺好的，同时很少人会关注你，内心戏不要太多<br>加强自己的专业知识，可以增强信心<br>主动承担责任，跟踪进度，给自己目标，每次会议发言一次。</p>\n<br/>\n<br/>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>从今天开始，每天从得到上学习，并且记录学习的收货，可摘抄，感想，收获等，不管记录的是多是少，都要每天更新。断更时，记录断更的原因。</p>\n<p>记录的维度暂时以周为单位，一周一个主题。写博客的目的还是为了个人提升，所以本周以提升个人能力为主题。</p>","more":"<p>问题：<br>在写的过程中发现，自己太啰嗦了，没有逻辑</p>\n<p>规定：表达有逻辑，语言精炼</p>\n<h1 id=\"自我提升\"><a href=\"#自我提升\" class=\"headerlink\" title=\"自我提升\"></a>自我提升</h1><h1 id=\"1-如何选择适合自己的书\"><a href=\"#1-如何选择适合自己的书\" class=\"headerlink\" title=\"1.如何选择适合自己的书\"></a>1.如何选择适合自己的书</h1><p>想去读一本书，却不知道从那本书开始，又或者读了很多的书，却毫无长进。那么我们如何去解决呢。《精进》的作者采铜老师在得到锦囊中分享了自己的心得。</p>\n<p>看书需要先从选书开始，直接碰到适合自己的书很难，还是需要我们自己主动去寻找书籍。</p>\n<ol>\n<li><strong>筛选</strong>：我们可以去筛选自己想要读的书，书籍排行榜，大V的推荐等。这一步不是为了盲目的跟从，主要的目的还是为了让自己知道，哦，原来还有这样一本书。提高自己的渠道的一种方法。</li>\n<li><strong>试读</strong>：选取一小部分去读，看看写的内容，自己是否感兴趣</li>\n<li><strong>泛读</strong>：从头到尾读一遍，了解结构，观点。分析对你有什么启发，形成对这本书的基本认识。</li>\n<li><strong>精读</strong>：想要透彻体悟书的思想，形成深层次的共鸣。就需要进行精读，这样你，你的思维，学习能力才会提升。</li>\n</ol>\n<p>在我看来读书的目的是增加自己见闻的一种方式。经验的传播最好的方式，是面对面的进行。书弥补了时间，空间等问题带来的阻碍。读书缺少了引导的粒度，需要读者自行去思考，由面到点，由点到线，再到面。付出实践方得成长。</p>\n<p><strong><font color=\"red\" >如何获取适合自己的东西</font></strong></p>\n<ul>\n<li>运气</li>\n<li>接触，尝试，经历，机会</li>\n</ul>\n<h1 id=\"2-如何搭建自己的知识体系\"><a href=\"#2-如何搭建自己的知识体系\" class=\"headerlink\" title=\"2.如何搭建自己的知识体系\"></a>2.如何搭建自己的知识体系</h1><p>在我看来知识体系，就如同三维的蜘蛛网，点与点相连，每个知识点是知识点1的延伸，又是知识点2的基础，轻盈而又有黏性。知识体系的搭建重要的数量与质量，脑袋空空，一知半解何谈体系。</p>\n<p>搭建体系从基础的概念开始，基础打牢才好扩展。学习知识，了解根源，背景，应用才是搭建体系的价值所在。搭建好基础后，由问题为引导，穿针引线，将知识串联起来，逐渐深入，深入之后进行发散，使之变得丰富和多元化，这样知识体系才会慢慢扩展起来。</p>\n<p>知识深入才能成为高手，当可以独当一面的时候，再去拓展知识的广度，需要注意的是，广度的增加是需要与你深入的领域相关的，而不是天马行空去涉猎。</p>\n<h1 id=\"3-如何建立自己的人脉\"><a href=\"#3-如何建立自己的人脉\" class=\"headerlink\" title=\"3.如何建立自己的人脉\"></a>3.如何建立自己的人脉</h1><p>回答问题之前，先普两个概念：人际关系网中的强关系和弱关系。<br>强关系和托关系理论是美国社会学家格兰诺维特提出的，</p>\n<p><strong>强关系</strong>:指个人的社会网络同性质较强，关系紧密，有很强的情感支撑，比如亲戚关系。<br><strong>弱关系</strong>:特点是个人的社会网络异质性较强关系不紧密没有太多的感情维系就是我们常说的泛泛之交。</p>\n<p>刚到一个城市时，同时通过强关系建立起初级网络，比如亲戚，老乡，老同学等等。之后通过职业，兴趣等建立次级网络。通过通过弱关系进行维持。与强关系相比，弱关系可以让你接触到更多的信息。</p>\n<p>在日常生活中，不要过度依赖维持初级网络，强关系本来就有很大的黏性，过度维持会阻碍人脉的建立。</p>\n<p>多结交网络中受欢迎的人，他们可以帮你带来更多的人脉，同时要提升自己的重要程度，让自己成为可以牵线搭桥的人。</p>\n<h1 id=\"4-被他人夸奖我们应该如何回应。\"><a href=\"#4-被他人夸奖我们应该如何回应。\" class=\"headerlink\" title=\"4.被他人夸奖我们应该如何回应。\"></a>4.被他人夸奖我们应该如何回应。</h1><p>一般情况下，夸奖别人是客套话，从而打开话题，所以不需要太当真。被夸奖后可以感谢对方，同时可以将话题引到对方身上，比如夸赞对方的衣着，或者聊聊对方的孩子或者最近发生的事，比如出去旅游了，咨询下旅游地的特色等等。</p>\n<h1 id=\"5-如何经营自己的朋友圈\"><a href=\"#5-如何经营自己的朋友圈\" class=\"headerlink\" title=\"5.如何经营自己的朋友圈\"></a>5.如何经营自己的朋友圈</h1><p>朋友圈是一张名片，经营的好可以提升个人品牌，用不好只能黑房间。先说说我自己的朋友圈。很少发动态，一张图片证明我没有拉黑你，哈哈。对应朋友的动态，有些朋友定期更新，配图和文字看着舒服，这些人，不由自主的会有好感。当然朋友圈中也有被拉黑的人，不乏朋友，亲戚，因为更新的过于频繁，内容乏味，枯燥，无意义的负面情绪，除非我对你有好感，不然不好意思拉黑。</p>\n<p>那如何去更新自己的朋友圈呢，一个不发朋友圈的来说说自己的观点，你敢信吗？</p>\n<p>首先为什么需要去更新朋友圈。更新朋友圈对看的人来说，可以对你有所了解，减少隔阂，及时很少联系，也能感觉对你很熟悉。它就是你的社会履历，是你对外的工作人格。经营好了可以提升你的个人品牌，获得更多的资源。</p>\n<p>如何去做呢：</p>\n<ul>\n<li>明确定位。先想想自己能够成为什么样的人，有个基本的人设。</li>\n<li>分析优势。找到自己擅长的事情，明确更新的内容方向</li>\n<li>主要更新时间。选择他人适合阅读的时间，大半夜发朋友圈，给鬼看呢。</li>\n<li>维护形象。朋友圈要展现正面，积极的一面，我本身就很烦躁的，还要看你瞎抱怨呢。</li>\n<li>不能过于平凡，定期更新有趣的内容。都是日常，不好意思我不想了解。</li>\n<li>主要目的。个原因就是找到沟通的诱因，回复评论时，主要可以延续话题。</li>\n</ul>\n<p>最后一点，如何去关注别人的朋友圈。展现友好的一面时，点赞，表示我在关注你，我同意的态度。注意敏感话题，可以私聊单不可直接评论。</p>\n<h1 id=\"6-如何添加了大牛的微信，不被拉黑\"><a href=\"#6-如何添加了大牛的微信，不被拉黑\" class=\"headerlink\" title=\"6.如何添加了大牛的微信，不被拉黑\"></a>6.如何添加了大牛的微信，不被拉黑</h1><p>与人打交道，重要的是学会换位思考</p>\n<ul>\n<li>态度要不卑不亢，唯唯诺诺会让人瞧不起</li>\n<li>让对方知道你的价值所在，并且可被对方用到</li>\n<li>找到相对平等的地方，在加微信，让对方对你有些了解，消除隔阂感</li>\n<li>多认识中间人，通过中间人引荐，更容易成功</li>\n</ul>\n<h1 id=\"7-部门会议上，怕出错，又想被注意到，该怎么办\"><a href=\"#7-部门会议上，怕出错，又想被注意到，该怎么办\" class=\"headerlink\" title=\"7.部门会议上，怕出错，又想被注意到，该怎么办\"></a>7.部门会议上，怕出错，又想被注意到，该怎么办</h1><p>这种担心在日常生活中，其实和常见。我认为主要的原因：<br>1：不自信，自己给自己的心里加压<br>2：没有过硬的专业知识去支撑着你  </p>\n<p>从根源出发，看看有什么解决的方案</p>\n<p>尽量与参会的人员混熟，减少陌生感<br>从他人角度去思考一下，一般同事间的包容还是挺好的，同时很少人会关注你，内心戏不要太多<br>加强自己的专业知识，可以增强信心<br>主动承担责任，跟踪进度，给自己目标，每次会议发言一次。</p>\n<br/>\n<br/>"},{"title":"设计模式六大原则","date":"2020-11-04T15:26:24.000Z","_content":"\n\n在书写代码之前规划好代码的接口，有助于提升代码的质量，同时利于后期代码的维护。在长久的软件开发过程中，前人总结了各种各样的模式。比较有名的还是24设计模式。同时提出了设计模式应该遵守的6大原则。设计模式应该尽可能的去遵循。\n\n## 单一职责原则\n\n各司其职，一个方法，一个类只负责一个功能。修改其中一个功能时，不会影响到其他的功能。\n\n## 里氏替换原则\n\n子类可以扩展父类的功能，但不能改变父类原有的功能。\n\n- 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法\n- 子类中可以增加自己特有的方法\n- 当子类中的方法实现了父类的抽象方法时，方法的后置条件要比父类更加严格。\n\n## 依赖倒置原则\n\n- 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象\n- 抽象不应该依赖于具体的实现，具体实现应该依赖于抽象\n\n## 接口隔离原则\n\n客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。\n\n## 迪米特法则\n\n即最少知道原则，就是一个对象应该对其他对象有尽可能少的了解。\n\n## 开闭原则\n\n软件中的对象，应该对应扩展时开放的，但是对于修改时封闭的。\n\n\n\n形象的来说，设计原则就好比邻居，儿子继承父业后，老祖宗的东西要传承，不能改变，但是自己可以增加其他的副业，弥补家用。\n邻里之间，应该保持距离，需要沟通菜刀，就不要提到杀猪刀的事，不应该知道的不要知道，你耕田，他织布就好。\n<br/>\n<br/>\n\n","source":"_posts/设计模式/设计模式原则.md","raw":"---\ntitle: 设计模式六大原则\ndate: 2020-11-04 23:26:24\ncategories: \n    - 设计模式\ntags: \n    - 代码\n---\n\n\n在书写代码之前规划好代码的接口，有助于提升代码的质量，同时利于后期代码的维护。在长久的软件开发过程中，前人总结了各种各样的模式。比较有名的还是24设计模式。同时提出了设计模式应该遵守的6大原则。设计模式应该尽可能的去遵循。\n\n## 单一职责原则\n\n各司其职，一个方法，一个类只负责一个功能。修改其中一个功能时，不会影响到其他的功能。\n\n## 里氏替换原则\n\n子类可以扩展父类的功能，但不能改变父类原有的功能。\n\n- 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法\n- 子类中可以增加自己特有的方法\n- 当子类中的方法实现了父类的抽象方法时，方法的后置条件要比父类更加严格。\n\n## 依赖倒置原则\n\n- 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象\n- 抽象不应该依赖于具体的实现，具体实现应该依赖于抽象\n\n## 接口隔离原则\n\n客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。\n\n## 迪米特法则\n\n即最少知道原则，就是一个对象应该对其他对象有尽可能少的了解。\n\n## 开闭原则\n\n软件中的对象，应该对应扩展时开放的，但是对于修改时封闭的。\n\n\n\n形象的来说，设计原则就好比邻居，儿子继承父业后，老祖宗的东西要传承，不能改变，但是自己可以增加其他的副业，弥补家用。\n邻里之间，应该保持距离，需要沟通菜刀，就不要提到杀猪刀的事，不应该知道的不要知道，你耕田，他织布就好。\n<br/>\n<br/>\n\n","slug":"设计模式/设计模式原则","published":1,"updated":"2020-11-16T11:38:12.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0w001o54vi96chdzrm","content":"<p>在书写代码之前规划好代码的接口，有助于提升代码的质量，同时利于后期代码的维护。在长久的软件开发过程中，前人总结了各种各样的模式。比较有名的还是24设计模式。同时提出了设计模式应该遵守的6大原则。设计模式应该尽可能的去遵循。</p>\n<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><p>各司其职，一个方法，一个类只负责一个功能。修改其中一个功能时，不会影响到其他的功能。</p>\n<h2 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h2><p>子类可以扩展父类的功能，但不能改变父类原有的功能。</p>\n<ul>\n<li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</li>\n<li>子类中可以增加自己特有的方法</li>\n<li>当子类中的方法实现了父类的抽象方法时，方法的后置条件要比父类更加严格。</li>\n</ul>\n<h2 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h2><ul>\n<li>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象</li>\n<li>抽象不应该依赖于具体的实现，具体实现应该依赖于抽象</li>\n</ul>\n<h2 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h2><p>客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>即最少知道原则，就是一个对象应该对其他对象有尽可能少的了解。</p>\n<h2 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h2><p>软件中的对象，应该对应扩展时开放的，但是对于修改时封闭的。</p>\n<p>形象的来说，设计原则就好比邻居，儿子继承父业后，老祖宗的东西要传承，不能改变，但是自己可以增加其他的副业，弥补家用。<br>邻里之间，应该保持距离，需要沟通菜刀，就不要提到杀猪刀的事，不应该知道的不要知道，你耕田，他织布就好。<br><br/><br><br/></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在书写代码之前规划好代码的接口，有助于提升代码的质量，同时利于后期代码的维护。在长久的软件开发过程中，前人总结了各种各样的模式。比较有名的还是24设计模式。同时提出了设计模式应该遵守的6大原则。设计模式应该尽可能的去遵循。</p>\n<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><p>各司其职，一个方法，一个类只负责一个功能。修改其中一个功能时，不会影响到其他的功能。</p>\n<h2 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h2><p>子类可以扩展父类的功能，但不能改变父类原有的功能。</p>\n<ul>\n<li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法</li>\n<li>子类中可以增加自己特有的方法</li>\n<li>当子类中的方法实现了父类的抽象方法时，方法的后置条件要比父类更加严格。</li>\n</ul>\n<h2 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h2><ul>\n<li>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象</li>\n<li>抽象不应该依赖于具体的实现，具体实现应该依赖于抽象</li>\n</ul>\n<h2 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h2><p>客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>即最少知道原则，就是一个对象应该对其他对象有尽可能少的了解。</p>\n<h2 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h2><p>软件中的对象，应该对应扩展时开放的，但是对于修改时封闭的。</p>\n<p>形象的来说，设计原则就好比邻居，儿子继承父业后，老祖宗的东西要传承，不能改变，但是自己可以增加其他的副业，弥补家用。<br>邻里之间，应该保持距离，需要沟通菜刀，就不要提到杀猪刀的事，不应该知道的不要知道，你耕田，他织布就好。<br><br/><br><br/></p>\n"},{"title":"简单工厂模式","date":"2020-11-16T11:41:31.000Z","_content":"","source":"_posts/设计模式/建造者模式/简单工厂模式.md","raw":"---\ntitle: 简单工厂模式\ndate: 2020-11-16 19:41:31\ncategories: \n    - 设计模式\ntags: \n    - 代码\n---\n","slug":"设计模式/建造者模式/简单工厂模式","published":1,"updated":"2020-11-16T11:42:42.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cki8f5y0x001s54vi5imjg42e","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[{"_id":"source/_posts/jvm/java-jvm-1/jvm_area.png","slug":"jvm_area.png","post":"cki8f5xzu000154vi8s6z7rdt","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-monitor/jps.png","slug":"jps.png","post":"cki8f5xzy000354vi586a6y9t","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1/cms.png","slug":"cms.png","post":"cki8f5y01000654vi4454255g","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1/GClog.png","slug":"GClog.png","post":"cki8f5y01000654vi4454255g","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1/parnew.png","slug":"parnew.png","post":"cki8f5y01000654vi4454255g","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm-1/serial.png","slug":"serial.png","post":"cki8f5y01000654vi4454255g","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/biaojiqingchu1.png","slug":"biaojiqingchu1.png","post":"cki8f5y02000754vi0tts5emn","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/biaojiqingchu2.png","slug":"biaojiqingchu2.png","post":"cki8f5y02000754vi0tts5emn","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/biaojizhengli.png","slug":"biaojizhengli.png","post":"cki8f5y02000754vi0tts5emn","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/biaojizhengli1.png","slug":"biaojizhengli1.png","post":"cki8f5y02000754vi0tts5emn","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/fuzhi1.png","slug":"fuzhi1.png","post":"cki8f5y02000754vi0tts5emn","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc-algorithm/fuzhi2.png","slug":"fuzhi2.png","post":"cki8f5y02000754vi0tts5emn","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-object/jubinchi.png","slug":"jubinchi.png","post":"cki8f5y03000854vi33l8h23e","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-object/zhijiezhizhen.png","slug":"zhijiezhizhen.png","post":"cki8f5y03000854vi33l8h23e","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-命令的使用/jps1.png","slug":"jps1.png","post":"cki8f5y05000c54vi16ie4gz8","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-命令的使用/jps2.png","slug":"jps2.png","post":"cki8f5y05000c54vi16ie4gz8","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-命令的使用/jps3.png","slug":"jps3.png","post":"cki8f5y05000c54vi16ie4gz8","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-命令的使用/stat1.png","slug":"stat1.png","post":"cki8f5y05000c54vi16ie4gz8","modified":0,"renderable":0},{"_id":"source/_posts/springboot/springboot-frist/springboot1.png","slug":"springboot1.png","post":"cki8f5y09000j54vi370l2tma","modified":0,"renderable":0},{"_id":"source/_posts/springboot/springboot-frist/springboot2.png","slug":"springboot2.png","post":"cki8f5y09000j54vi370l2tma","modified":0,"renderable":0},{"_id":"source/_posts/springboot/springboot-frist/springboot3.png","slug":"springboot3.png","post":"cki8f5y09000j54vi370l2tma","modified":0,"renderable":0},{"_id":"source/_posts/springboot/springboot-frist/springboot4.png","slug":"springboot4.png","post":"cki8f5y09000j54vi370l2tma","modified":0,"renderable":0},{"_id":"source/_posts/blog/firstBlog/11.png","slug":"11.png","post":"cki8f5y0c000r54vi9vxa6nso","modified":0,"renderable":0},{"_id":"source/_posts/blog/firstBlog/newfirstBlog.png","slug":"newfirstBlog.png","post":"cki8f5y0c000r54vi9vxa6nso","modified":0,"renderable":0},{"_id":"source/_posts/blog/firstBlog/nodejs.png","slug":"nodejs.png","post":"cki8f5y0c000r54vi9vxa6nso","modified":0,"renderable":0},{"_id":"source/_posts/tomcat/tomcat-1-http协议/http原理.png","slug":"http原理.png","post":"cki8f5y0g000w54vi0yae87xg","modified":0,"renderable":0},{"_id":"source/_posts/日常/jar包冲突/maven插件.png","slug":"maven插件.png","post":"cki8f5y0k001354vi9oq74l4y","modified":0,"renderable":0},{"_id":"source/_posts/日常/jar包冲突/启动失败.jpg","slug":"启动失败.jpg","post":"cki8f5y0k001354vi9oq74l4y","modified":0,"renderable":0},{"_id":"source/_posts/日常/jar包冲突/界面.png","slug":"界面.png","post":"cki8f5y0k001354vi9oq74l4y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/java-jvm-gc/GCRoots.png","slug":"GCRoots.png","post":"cki8f5y0n001a54vib8zshsv8","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cki8f5y02000754vi0tts5emn","category_id":"cki8f5xzz000454vi2bmd9v78","_id":"cki8f5y07000f54vi2oek6tcb"},{"post_id":"cki8f5xzu000154vi8s6z7rdt","category_id":"cki8f5xzz000454vi2bmd9v78","_id":"cki8f5y0a000k54vierdidnib"},{"post_id":"cki8f5y03000854vi33l8h23e","category_id":"cki8f5xzz000454vi2bmd9v78","_id":"cki8f5y0b000n54viaqe720cp"},{"post_id":"cki8f5y05000c54vi16ie4gz8","category_id":"cki8f5xzz000454vi2bmd9v78","_id":"cki8f5y0e000s54vi0dhk0cq7"},{"post_id":"cki8f5xzy000354vi586a6y9t","category_id":"cki8f5xzz000454vi2bmd9v78","_id":"cki8f5y0f000v54vibmcr1588"},{"post_id":"cki8f5y01000654vi4454255g","category_id":"cki8f5xzz000454vi2bmd9v78","_id":"cki8f5y0j000z54vidzx06zfu"},{"post_id":"cki8f5y0e000u54vi8gp261rl","category_id":"cki8f5xzz000454vi2bmd9v78","_id":"cki8f5y0l001454vigagw8gy9"},{"post_id":"cki8f5y09000j54vi370l2tma","category_id":"cki8f5y0b000o54vi0p4y2oc5","_id":"cki8f5y0m001954vi2lnggwrq"},{"post_id":"cki8f5y0a000m54vif8b94c32","category_id":"cki8f5y0b000o54vi0p4y2oc5","_id":"cki8f5y0n001b54vi5o7s59hk"},{"post_id":"cki8f5y0c000r54vi9vxa6nso","category_id":"cki8f5y0l001554vi0ufgavhf","_id":"cki8f5y0q001i54vi1dlr36an"},{"post_id":"cki8f5y0n001a54vib8zshsv8","category_id":"cki8f5xzz000454vi2bmd9v78","_id":"cki8f5y0w001m54vi2wnb2671"},{"post_id":"cki8f5y0g000w54vi0yae87xg","category_id":"cki8f5y0n001c54vi9xk64s8p","_id":"cki8f5y0x001p54vi5ncrb43n"},{"post_id":"cki8f5y0k001354vi9oq74l4y","category_id":"cki8f5y0x001q54vidb4fccmk","_id":"cki8f5y10001y54vifc5t4yn4"},{"post_id":"cki8f5y0m001854vi6f8lbcab","category_id":"cki8f5y0q001j54vi6sru7iqh","_id":"cki8f5y10002154vi6ux8bs91"},{"post_id":"cki8f5y0o001e54viag45g10k","category_id":"cki8f5y0z001x54vibyt77vm7","_id":"cki8f5y11002654vie7tkaby4"},{"post_id":"cki8f5y0r001l54vi4plreys6","category_id":"cki8f5y0z001x54vibyt77vm7","_id":"cki8f5y13002b54vi0kfbcusy"},{"post_id":"cki8f5y0w001o54vi96chdzrm","category_id":"cki8f5y12002954vi57cj6iq8","_id":"cki8f5y14002f54vi8bm60svq"},{"post_id":"cki8f5y0j001154vi4m0fd1vs","category_id":"cki8f5y0q001j54vi6sru7iqh","_id":"cki8f5y16002l54vi3uth7xs8"},{"post_id":"cki8f5y0j001154vi4m0fd1vs","category_id":"cki8f5y13002c54vi57g5eht9","_id":"cki8f5y16002n54vi1tidbf09"},{"post_id":"cki8f5y0x001s54vi5imjg42e","category_id":"cki8f5y12002954vi57cj6iq8","_id":"cki8f5y17002p54vi04ra5mdo"},{"post_id":"cki8f5y0p001g54vi9hzmc9bj","category_id":"cki8f5y0q001j54vi6sru7iqh","_id":"cki8f5y17002r54vi026f2byp"},{"post_id":"cki8f5y0p001g54vi9hzmc9bj","category_id":"cki8f5y13002c54vi57g5eht9","_id":"cki8f5y17002s54vi8ntz19p5"}],"PostTag":[{"post_id":"cki8f5y02000754vi0tts5emn","tag_id":"cki8f5y01000554vigrscco9n","_id":"cki8f5y05000b54vi7cfch73n"},{"post_id":"cki8f5xzu000154vi8s6z7rdt","tag_id":"cki8f5y01000554vigrscco9n","_id":"cki8f5y07000d54vi6wyf5kv5"},{"post_id":"cki8f5y03000854vi33l8h23e","tag_id":"cki8f5y01000554vigrscco9n","_id":"cki8f5y09000i54vic6hr3gbj"},{"post_id":"cki8f5y05000c54vi16ie4gz8","tag_id":"cki8f5y01000554vigrscco9n","_id":"cki8f5y0a000l54vidtb52ds0"},{"post_id":"cki8f5xzy000354vi586a6y9t","tag_id":"cki8f5y01000554vigrscco9n","_id":"cki8f5y0c000q54vih11j1ex4"},{"post_id":"cki8f5y01000654vi4454255g","tag_id":"cki8f5y01000554vigrscco9n","_id":"cki8f5y0e000t54vi6gigb0zn"},{"post_id":"cki8f5y0e000u54vi8gp261rl","tag_id":"cki8f5y01000554vigrscco9n","_id":"cki8f5y0j001054vi0cwj38b6"},{"post_id":"cki8f5y09000j54vi370l2tma","tag_id":"cki8f5y0b000p54vi8ihj2i7v","_id":"cki8f5y0k001254vi8lxq94fc"},{"post_id":"cki8f5y0a000m54vif8b94c32","tag_id":"cki8f5y0b000p54vi8ihj2i7v","_id":"cki8f5y0m001754vif5fme3tx"},{"post_id":"cki8f5y0c000r54vi9vxa6nso","tag_id":"cki8f5y0l001654vibulmcjzo","_id":"cki8f5y0p001f54viewyshi57"},{"post_id":"cki8f5y0n001a54vib8zshsv8","tag_id":"cki8f5y01000554vigrscco9n","_id":"cki8f5y0q001h54vi13ll8ks7"},{"post_id":"cki8f5y0g000w54vi0yae87xg","tag_id":"cki8f5y0o001d54vi59ut0gz5","_id":"cki8f5y0w001n54vidy2r1qt5"},{"post_id":"cki8f5y0j001154vi4m0fd1vs","tag_id":"cki8f5y0r001k54vigp2x3t7h","_id":"cki8f5y0z001v54vi5omhcbz7"},{"post_id":"cki8f5y0j001154vi4m0fd1vs","tag_id":"cki8f5y0x001r54vigag8807c","_id":"cki8f5y0z001w54vieyangtgv"},{"post_id":"cki8f5y0k001354vi9oq74l4y","tag_id":"cki8f5y0z001u54vi1w4sbz77","_id":"cki8f5y10002054vie6qfd9rt"},{"post_id":"cki8f5y0m001854vi6f8lbcab","tag_id":"cki8f5y10001z54vi0see4q2d","_id":"cki8f5y11002454vif1su5vx1"},{"post_id":"cki8f5y0o001e54viag45g10k","tag_id":"cki8f5y11002354vihat24mja","_id":"cki8f5y12002854vicek70wfc"},{"post_id":"cki8f5y0p001g54vi9hzmc9bj","tag_id":"cki8f5y12002754vieclodua8","_id":"cki8f5y14002e54vi09miecmq"},{"post_id":"cki8f5y0p001g54vi9hzmc9bj","tag_id":"cki8f5y0x001r54vigag8807c","_id":"cki8f5y14002h54vi2uahf0qr"},{"post_id":"cki8f5y0r001l54vi4plreys6","tag_id":"cki8f5y11002354vihat24mja","_id":"cki8f5y15002j54vi8fx47xmd"},{"post_id":"cki8f5y0w001o54vi96chdzrm","tag_id":"cki8f5y15002i54vi80ftdsa5","_id":"cki8f5y16002o54vibo28d3rr"},{"post_id":"cki8f5y0x001s54vi5imjg42e","tag_id":"cki8f5y15002i54vi80ftdsa5","_id":"cki8f5y17002q54vi4o4p6h4y"}],"Tag":[{"name":"JVM","_id":"cki8f5y01000554vigrscco9n"},{"name":"SpringBoot","_id":"cki8f5y0b000p54vi8ihj2i7v"},{"name":"博客","_id":"cki8f5y0l001654vibulmcjzo"},{"name":"tomcat","_id":"cki8f5y0o001d54vi59ut0gz5"},{"name":"vscode","_id":"cki8f5y0r001k54vigp2x3t7h"},{"name":"技巧","_id":"cki8f5y0x001r54vigag8807c"},{"name":"开发环境","_id":"cki8f5y0z001u54vi1w4sbz77"},{"name":"lambda","_id":"cki8f5y10001z54vi0see4q2d"},{"name":"读书笔记","_id":"cki8f5y11002354vihat24mja"},{"name":"markdown","_id":"cki8f5y12002754vieclodua8"},{"name":"代码","_id":"cki8f5y15002i54vi80ftdsa5"}]}}