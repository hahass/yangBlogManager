---
title: 垃圾回收器算法的实现
date: 2019-05-27 15:49:28
categories: 
    - JAVA_JVM
tags: 
    - JVM
---

## HOTSPOT算法实现
### 枚举根节点

GC Roots主要在全局性的引用（例如常量或者类静态属性）与执行上下文（例如栈帧中的本地变量表）中，java进行可达性分析时，对执行时间的敏感还体现在GC停顿上，因为分析工作必须在一个能确保一致性（分析过程中对象引用关系不能再不断变化）的快照中进行，这点是导致GC进行时必须停顿所有的java执行线程的一个重要原因。即使是在GMS收集器中，枚举枚举根节点也要停顿。

在HotSpot中使用OopMap的数据结构来保存对象的引用，从而在执行分析时不需要一个不漏的检查完所有的执行上下文和全局的引用位置，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。

### 安全点

HotSpot没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，就是安全点（SafePoint）。即程序执行时并非在所有的地方都要停顿下来开始GC，只有到达安全点才能暂停。
SafePoint选定太少会让gc等待时间太长，太多会增加运行时的负荷。

所以安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准进行选定的-因为每条指令执行时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行。“长时间执行”的最明显特征就是指令序列复用，例如方法调用，循环跳转，异常跳转等，所有具有这些功能的指令才会产生SafePoint。

对于SafePoint，另一个需要考虑的问题是如何在GC发生时让所有线程都跑到最近的安全点上在停顿下来。有两个方案：

- 抢先式中断

不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。


- 主动式中断

当GC需要中断线程的时候，不直接对线程操作，仅设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真就自己中断挂起。轮询标志的地方和安全点是重合的，另外在加上创建对象需要分配内存的地方。



### 安全区域

安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。
在线程执行到安全区域中的代码时，首先标识自己进入了安全区域，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了，在线程要离开安全区域，要检查是否已经完成了根节点枚举，如果完成了那现场就继续执行，否则必须等待直到收到可以离开安全区域的信号位置。


## 垃圾收集器

收集算法是内存回收的方法理论，垃圾收集器就是内存回收的具体实现。java虚拟机规范没有对垃圾收集器如何实现有规定，因此不同厂商、版本提供的垃圾收集器可能大不相同。

> <font color='green'>Serial(/sɪəriəl/)收集器</font>

Serial 收集器是最基本、历史最悠久的收集器。这个收集器是一个单线程的收集器，单线程的意义不仅仅说明它是只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到收集完成。

![serial.png](./serial.png)

目前为止，Serial依然是虚拟机运行在Client模式下的默认新生代收集器。
优点：
简单，高效。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集小路。

> <font color='green'>ParNew收集器</font>

parNew收集器其实就是Serial收集器的多线程版本，HotSpot第一款真正意义上的并发收集器

![parnew.png](./parnew.png)

参数：
- -XX:+UseConcMarkSweepGC：选择后的默认新生代收集器
- -XX:+UserParNewGC:强制指定
- -XX:ParallelGCThreads：限制垃圾收集线程数

> <font color='green'>Parallel Scavenge收集器</font>

新生代收集器、使用复制算法、并行的多线程收集器。

特点：
关注点与其他收集器不同。CMS等收集器关注点是尽可能的缩短垃圾回收时用户线程停顿的时间，而Parallel Scavenge收集器目的则是达到一个可控制的吞吐量。吞吐量就是CPU运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行代码时间/(运行代码时间+垃圾收集时间)。

停顿时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效的利用CPU时间，尽快完成程序的运算任务，主要适合后台运算而不需要太多交互的任务。

参数：

- -XX:MaxGCPauseMillis:控制最大垃圾收集停顿时间

参数值是一个大于0的毫米数，收集器尽可能保证内存回收花费的时间不超过设定值。不是说参数调至越小垃圾收集的时间越快，GC停顿时间压缩是以牺牲吞吐量和新生代空间来换取的。

- -XX:GCTimeRatil:设置吞吐量大小
参数值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量倒数，如果参数设置为19，那么预先的最大GC时间占总时间的5%（1/(1+19)）,默认为99，就是允许最大1%（1/(1+99)）的垃圾收集时间。

- -XX:UseAdaptiveSizePolicy:这个一个开关参数，打开后，不需要手动指定新生代的大小、Eden和Survivor区的比例，晋升老年代对象年龄等细节参数，会动态调整这些参数以提供最适合的停顿时间或者最大的吞吐量。

> <font color='green'>Serial Old 收集器</font>

Serial Older 是 Serial 收集器的老年代版本，同样是一大单线程收集器，使用标记-整理算法。

> <font color='green'>Parallel Old 收集器</font>

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和标记-整理算法。

> <font color='green'>CMS 收集器</font>

CMS(Concurent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前java集中在互联网网站或者B/S系统服务端，比较重视服务响应时间，给用户带来比较好的体验，CMS非常服务符合这类需求。

CMS采用标记-清除算法，整个步骤包括：

- 初始标记（CMS initial mark）
仅仅标记一下GC Roots能直接关联到的对象，速度很快。
- 并发标记（CMS concurrent mark）
进行GC Roots Tracing的过程
- 重新标记（CMS remark）
为了修正并发标记期间因用户程序继续运作而导致标志产生变动的那一部分对象的标记记录，这个阶段停顿时间一般会比初始化阶段稍长一些，但远比并发标记的时间短。
- 并发清除（CMS concurrent sweep）

初始标记和重新标记步骤任然需要“stop the world”。整个过程中耗时比较长的并发标记和并发清除过程是与用户线程一起工作的。

![cms.png](./cms.png)

**优点**
并发收集，低停顿

**缺点**
- 对CPU资源非常敏感
并发阶段，它不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐会降低。
- 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC。
- 产生大量空间碎片 


> <font color="green">G1收集器</font>

G1是面向服务端的垃圾收集器。

**特点**
- 并行与并发
充分利用多CPU多核环境下的硬件优势，缩短stop the world停顿时间。
- 分代收集
- 空间整合
G1 从整体来看基于标记-整理算法实现，从局部看基于复制算法实现，运行期间不会产生内存碎片。
- 可预测的停顿


**步骤**

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

初始标记仅仅是标记下GC Roots能直接关联到的对象，并且修改TAMS（next top at mark start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程。
并发标记是从GC Roots开始对堆中对象进行可达性分析，找到存活的对象，这段耗时长，但可与用户程序并发执行。
最终标记是为了修正并发标记期间因用户程序继续运作而导致标记发生变化的那一部分标记记录。
筛选回收首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

## 理解GC日志

下面是一段GC日志：

![GClog.png](./GClog.png)

"33.125：" 和 "100.67：" 代表GC发生的时间，是从java虚拟机启动以来经过的描述。

“[GC”和"[Full GC" 说明这次垃圾收集的停顿类型，而不是用来区分新生代还是老年代GC的。有 Full 说明这次GC是发生了“stop  the world”的。

"[DefNew"、"[Tenured"、"[Perm"标识GC发生区域，这里显示的区域名和使用的GC收集器是密切相关的。如果使用Serial收集器中的新生代名称"Default New Generation"，显示"[DefNew"。如果使用ParNew,则为"[Tenured"，使用Parallel Scavenge收集器，那它配套的新生代名称为"PSYoungGen" 老年代和永久代同理，名称由收集器决定。

"3324K->152K(3712k)"表示 GC前该内存区域已使用容量 -> GC 后该内存区域已使用容量（该内存区域总容量）。

方括号之外的"3324K->152K(11904)" 表示 GC前java堆已使用容量->GC 后该java堆已使用容量（java堆总容量）。
"0.0025925 secs"表示内存区域GC所占用的时间，单位秒。