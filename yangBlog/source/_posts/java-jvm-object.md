---
title: JVM学习笔记-java对象
date: 2019-05-22 15:47:30
categories: 
    - JAVA_JVM
tags: 
    - JVM
---
&nbsp; &nbsp; &nbsp; &nbsp;我们在学习了java虚拟机的内存知识后，我们接下来研究下对象的在java堆中分配、布局和访问的全过程。


###  <font color=#008000>对象的创建</font>

&nbsp; &nbsp; &nbsp; &nbsp;在我们开发的过程中，用到的最多的当然还是通过 new 关键字去创建一个对象，那么在创建是一个怎样的过程呢？

&nbsp; &nbsp; &nbsp; &nbsp;1.在执行 new 指令时，会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引入代表的类是否已被加载、解析和初始化。如果没有就需要就行响应的类加载过程。（加载过程后面会说）

&nbsp; &nbsp; &nbsp; &nbsp;2.在类加载检查通过后，会为新生的对象分配内存空间，对象所需要的内存空间，在类加载完成后便可完全确定下来，为对象分配空间等同于在java堆中划分出一块内存。分配内存空间有两种分配方式：

- 指针碰撞

&nbsp; &nbsp; &nbsp; &nbsp;java堆的内存空间是**规整**的，使用的内存空间放在一起，空闲的内存空间放在一起，中间使用一个指针作为分界点的指示器。所分配的内存就是仅仅把指针箱空闲的那边挪动一段与对象大小相等的距离。

- 空闲列表

&nbsp; &nbsp; &nbsp; &nbsp;java堆内存空间不是**规整**的，使用的和没有使用的交错在一起，虚拟机会维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一个块足够大的空间划分给对象实例，并更新列表上的记录。

&nbsp; &nbsp; &nbsp; &nbsp; 具体使用哪种方式取决于java堆是否是规整的，而是否规整取决于垃圾收集器是否带有压缩整理功能决定。所以在使用Serial、ParNew等带有Compact过程的收集器，系统使用分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的采用空闲列表。
&nbsp; &nbsp; &nbsp; &nbsp;在划分空间的时候，如果频繁的创建对象，就会出现线程安全问题。比如两个线程A和B，虚拟机在为A分配内存的时候，指针还没有来得及修改，对象B同时使用了原来的指针来分配内存。决定方法有两种，
一种是使用CAS配上失败重试的方式保证更新操作的原子性。
另一种是按照线程的维度去分配空间。每个线程会预先分配到一小块的内存，称为<font color="red">本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</font>。需要分配内存的时候，在该线程的TLAB上去分配，只有TLAB用完了，并分配新的TLAB才需要同步锁定。通过-XX:+/-UseTLAB参数设置是否使用TLAB。

&nbsp; &nbsp; &nbsp; &nbsp;3.分配内存后，虚拟机需要将分配的内存空间都初始化为零值。从而保证对象的实例字段在java代码中可以不赋初始值就可以直接使用。

&nbsp; &nbsp; &nbsp; &nbsp;4.接下来要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象头中。

&nbsp; &nbsp; &nbsp; &nbsp;5.完成上述工作，需要执行 init 方法，把对象按照程序员的意愿进行初始化。这样一个真正的对象才算完全生产出来。


###  <font color=#008000>对象的内存布局</font>

&nbsp; &nbsp; &nbsp; &nbsp;对象的存储布局分为三个区域：对象头（Header）、实例数据（Instant Data）和对其填充（Padding）

#### 对象头

&nbsp; &nbsp; &nbsp; &nbsp;第一部分用于存储对象自身运行时数据，哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，官方称为“Mark Word”。这部分数据的长度在32位和64位的虚拟机上分别是32bit 和 64bit。Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储更多的信息。他会根据对象的状态复用自己的存储空间。比如，在32位的HotSpot虚拟机上，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中，25bit用于存储对象的哈希码，4bit用于存储对象的分代年龄，2bit存储锁标志位，1bit固定为0。而其他状态下的存储如下。

存储内容|标志位|状态
:-:|:-:|:-:
对象哈希码、对象分代年龄|01|未锁定
指向锁记录的指针|00|轻量级锁
执行重量级锁的指针|10|膨胀（重量级锁定）
空，不需要记录信息|11|GC标志
偏向线程ID、偏向时间戳、对象分代年龄|01|可偏向

&nbsp; &nbsp; &nbsp; &nbsp; 另一部分是类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。但是不是所有的虚拟机都需要在对象数据上保留类型指针，也就是说查找对象的元数据信息并不是一定需要经过对象本身。如果对象是一个java数组，那对象头还需要一块用于记录数据长度的数据，因为虚拟机可以通过普通的java对象的元数据信息确定java对象的大小，但是从数据的元数据中无法确定数组的大小。

### 实例数据

&nbsp; &nbsp; &nbsp; &nbsp; 对象真正存储的有效信息。也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

### 对其填充

&nbsp; &nbsp; &nbsp; &nbsp; 不是必然存在额，也没有特殊的意义，仅仅起着占位符的作用。HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍。换句话，就是对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。


###  <font color=#008000>对象的访问定位</font>

&nbsp; &nbsp; &nbsp; &nbsp;java程序通过栈上的reference数据来操作堆上的具体对象。reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义通过何种方式去定位、访问堆中对象的具体位置，所以对象访问方式取决于虚拟机事项而定。目前访问方式主要有两种：

- 使用句柄

java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。

使用句柄最大的好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。
![句柄池](./jubinchi.png)



- 直接指针

java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

使用直接指针速度更快，由于对象访问在java中非常频繁，这类开销积少成多，也是一项非常可观的执行成本。HotSpot就是使用直接指针。

![直接指针](./zhijiezhizhen.png)


