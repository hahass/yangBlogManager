---
title: JVM学习笔记-垃圾回收机制
date: 2019-05-24 16:06:15
categories: 
    - JAVA_JVM
tags: 
    - JVM
---

&#160; &#160; &#160; &#160;我们来学习一下jvm中比较重要的一块内容-GC。那么我们学习了GC与内存分配，能做什么呢？ 当我们需要排除各种内存溢出、内存泄漏等问题时，当垃圾收集成为系统大道更高并发的瓶颈时，我们就需要对GC实施必要的监控和调节。


### 哪些对象可变回收
&#160; &#160; &#160; &#160;垃圾回收器会定期回收堆内存中不在被使用的对象，通常判断对象是否需要被回收，有两种方式，引用计数法和可达性分析

#### 引用计数法

&#160; &#160; &#160; &#160;每个对象都有一个引用计数器，每当有一个地方引用该对象，引用计数就会+1，如果引用失效就会-1，当引用计数值为0的时候，这个对象就不在被使用。这种实现方式简单，判断效率高。但是他<font color='red'>存在一个问题，就是如果对象相互循环引用，那么这些对象就不能被回收</font>。java虚拟机没有采用这种实现方式。

```
public class TestGC{

    public Object instance = null;
    private byte[] bigSize = new byte[1024*1024*2];

    public static void main(String[] args){

        // o1 和 o2 相互引用
        TestGC o1 = new TestGC();
        TestGC o2 = new TestGC();
        o1.instance = o2;
        o2.instance = o1;

        //此时两个对象都不能再被访问，但是他们相互引用对方，引用计数值都不是0
        o1 = null;
        o2 = null;
        //假设在这里发生GC，他们并不会被回收
        System.gc();
    }

}

```

#### 可达性分析

&#160; &#160; &#160; &#160;从GC Roots开始向下搜索，搜索走过的路径称为引用链，当无法从GC Roots通过引用链到达某个对象，那么这个对象就是不可达，需要被回收。

java中，以下可作为GC Roots对象：

- 虚拟机栈（栈帧中国的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

![GC Roots](./GCRoots.png)

### 引用


jdk1.2之后，java对引用进行了扩展，将引用分为强引用，软引用，弱引用和虚引用。四种引用强度一次逐渐减弱。

- 强引用

强引用在java代码中是最常见的， 当我们new一个对象的时候，就是一个强引用。只要强引用存在，垃圾回收机制就不会回收对象。

- 软引用

软引用是描述一些有用但是非必须的对象。系统在发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果系统存在足够的内存，这些对象不会被回收，如果内存不足，则会回收这些对象。java提供SoftReference类实现软引用。

- 弱引用

弱引用描述非必需对象的。弱引用的对象只能生存到下一次垃圾回收之前。当开始垃圾回收时，不过内存是否足够都会回收弱引用的对象。java提供WeakReference类来实现弱引用。

- 虚引用

一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用主要是为了该对象在垃圾收集器回收会收到一个系统通知。java提供PhantomReference类来实现。

